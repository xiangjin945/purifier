L 1 "app\bim_intc.c"
N/**
N ****************************************************************************************
N *
N * @file bim_intc.c
N *
N * @brief Definition of the Interrupt Controller (INTCTRL) API.
N *
N * Copyright (C) RivieraWaves 2009-2015
N *
N *
N ****************************************************************************************
N */ 
N
N#include "bim_intc.h"
L 1 "app\bim_intc.h" 1
N/**
N ****************************************************************************************
N *
N * @file bim_intc.c
N *
N * @brief Definition of the Interrupt Controller (INTCTRL) API.
N *
N * Copyright (C) RivieraWaves 2009-2015
N *
N *
N ****************************************************************************************
N */
N#include <stdint.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\stdint.h" 1
N/* Copyright (C) ARM Ltd., 1999,2014 */
N/* All rights reserved */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: agrant $
N */
N
N#ifndef __stdint_h
N#define __stdint_h
N#define __ARMCLIB_VERSION 5060044
N
N  #ifdef __INT64_TYPE__
S    /* armclang predefines '__INT64_TYPE__' and '__INT64_C_SUFFIX__' */
S    #define __INT64 __INT64_TYPE__
N  #else
N    /* armcc has builtin '__int64' which can be used in --strict mode */
N    #define __INT64 __int64
N    #define __INT64_C_SUFFIX__ ll
N  #endif
N  #define __PASTE2(x, y) x ## y
N  #define __PASTE(x, y) __PASTE2(x, y)
N  #define __INT64_C(x)  __ESCAPE__(__PASTE(x, __INT64_C_SUFFIX__))
N  #define __UINT64_C(x)  __ESCAPE__(__PASTE(x ## u, __INT64_C_SUFFIX__))
N  #if defined(__clang__) || (defined(__ARMCC_VERSION) && !defined(__STRICT_ANSI__))
X  #if 0L || (1L && !0L)
N    /* armclang and non-strict armcc allow 'long long' in system headers */
N    #define __LONGLONG long long
N  #else
S    /* strict armcc has '__int64' */
S    #define __LONGLONG __int64
N  #endif
N
N  #ifndef __STDINT_DECLS
N  #define __STDINT_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N
N/*
N * 'signed' is redundant below, except for 'signed char' and if
N * the typedef is used to declare a bitfield.
N */
N
N    /* 7.18.1.1 */
N
N    /* exact-width signed integer types */
Ntypedef   signed          char int8_t;
Ntypedef   signed short     int int16_t;
Ntypedef   signed           int int32_t;
Ntypedef   signed       __INT64 int64_t;
Xtypedef   signed       __int64 int64_t;
N
N    /* exact-width unsigned integer types */
Ntypedef unsigned          char uint8_t;
Ntypedef unsigned short     int uint16_t;
Ntypedef unsigned           int uint32_t;
Ntypedef unsigned       __INT64 uint64_t;
Xtypedef unsigned       __int64 uint64_t;
N
N    /* 7.18.1.2 */
N
N    /* smallest type of at least n bits */
N    /* minimum-width signed integer types */
Ntypedef   signed          char int_least8_t;
Ntypedef   signed short     int int_least16_t;
Ntypedef   signed           int int_least32_t;
Ntypedef   signed       __INT64 int_least64_t;
Xtypedef   signed       __int64 int_least64_t;
N
N    /* minimum-width unsigned integer types */
Ntypedef unsigned          char uint_least8_t;
Ntypedef unsigned short     int uint_least16_t;
Ntypedef unsigned           int uint_least32_t;
Ntypedef unsigned       __INT64 uint_least64_t;
Xtypedef unsigned       __int64 uint_least64_t;
N
N    /* 7.18.1.3 */
N
N    /* fastest minimum-width signed integer types */
Ntypedef   signed           int int_fast8_t;
Ntypedef   signed           int int_fast16_t;
Ntypedef   signed           int int_fast32_t;
Ntypedef   signed       __INT64 int_fast64_t;
Xtypedef   signed       __int64 int_fast64_t;
N
N    /* fastest minimum-width unsigned integer types */
Ntypedef unsigned           int uint_fast8_t;
Ntypedef unsigned           int uint_fast16_t;
Ntypedef unsigned           int uint_fast32_t;
Ntypedef unsigned       __INT64 uint_fast64_t;
Xtypedef unsigned       __int64 uint_fast64_t;
N
N    /* 7.18.1.4 integer types capable of holding object pointers */
N#if __sizeof_ptr == 8
X#if 4 == 8
Stypedef   signed       __INT64 intptr_t;
Stypedef unsigned       __INT64 uintptr_t;
N#else
Ntypedef   signed           int intptr_t;
Ntypedef unsigned           int uintptr_t;
N#endif
N
N    /* 7.18.1.5 greatest-width integer types */
Ntypedef   signed     __LONGLONG intmax_t;
Xtypedef   signed     long long intmax_t;
Ntypedef unsigned     __LONGLONG uintmax_t;
Xtypedef unsigned     long long uintmax_t;
N
N
N#if !defined(__cplusplus) || defined(__STDC_LIMIT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.2.1 */
N
N    /* minimum values of exact-width signed integer types */
N#define INT8_MIN                   -128
N#define INT16_MIN                -32768
N#define INT32_MIN          (~0x7fffffff)   /* -2147483648 is unsigned */
N#define INT64_MIN  __INT64_C(~0x7fffffffffffffff) /* -9223372036854775808 is unsigned */
N
N    /* maximum values of exact-width signed integer types */
N#define INT8_MAX                    127
N#define INT16_MAX                 32767
N#define INT32_MAX            2147483647
N#define INT64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of exact-width unsigned integer types */
N#define UINT8_MAX                   255
N#define UINT16_MAX                65535
N#define UINT32_MAX           4294967295u
N#define UINT64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.2 */
N
N    /* minimum values of minimum-width signed integer types */
N#define INT_LEAST8_MIN                   -128
N#define INT_LEAST16_MIN                -32768
N#define INT_LEAST32_MIN          (~0x7fffffff)
N#define INT_LEAST64_MIN  __INT64_C(~0x7fffffffffffffff)
N
N    /* maximum values of minimum-width signed integer types */
N#define INT_LEAST8_MAX                    127
N#define INT_LEAST16_MAX                 32767
N#define INT_LEAST32_MAX            2147483647
N#define INT_LEAST64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of minimum-width unsigned integer types */
N#define UINT_LEAST8_MAX                   255
N#define UINT_LEAST16_MAX                65535
N#define UINT_LEAST32_MAX           4294967295u
N#define UINT_LEAST64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.3 */
N
N    /* minimum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MIN           (~0x7fffffff)
N#define INT_FAST16_MIN          (~0x7fffffff)
N#define INT_FAST32_MIN          (~0x7fffffff)
N#define INT_FAST64_MIN  __INT64_C(~0x7fffffffffffffff)
N
N    /* maximum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MAX             2147483647
N#define INT_FAST16_MAX            2147483647
N#define INT_FAST32_MAX            2147483647
N#define INT_FAST64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of fastest minimum-width unsigned integer types */
N#define UINT_FAST8_MAX            4294967295u
N#define UINT_FAST16_MAX           4294967295u
N#define UINT_FAST32_MAX           4294967295u
N#define UINT_FAST64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.4 */
N
N    /* minimum value of pointer-holding signed integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define INTPTR_MIN INT64_MIN
N#else
N#define INTPTR_MIN INT32_MIN
N#endif
N
N    /* maximum value of pointer-holding signed integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define INTPTR_MAX INT64_MAX
N#else
N#define INTPTR_MAX INT32_MAX
N#endif
N
N    /* maximum value of pointer-holding unsigned integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define UINTPTR_MAX UINT64_MAX
N#else
N#define UINTPTR_MAX UINT32_MAX
N#endif
N
N    /* 7.18.2.5 */
N
N    /* minimum value of greatest-width signed integer type */
N#define INTMAX_MIN  __ESCAPE__(~0x7fffffffffffffffll)
N
N    /* maximum value of greatest-width signed integer type */
N#define INTMAX_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum value of greatest-width unsigned integer type */
N#define UINTMAX_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.3 */
N
N    /* limits of ptrdiff_t */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define PTRDIFF_MIN INT64_MIN
S#define PTRDIFF_MAX INT64_MAX
N#else
N#define PTRDIFF_MIN INT32_MIN
N#define PTRDIFF_MAX INT32_MAX
N#endif
N
N    /* limits of sig_atomic_t */
N#define SIG_ATOMIC_MIN (~0x7fffffff)
N#define SIG_ATOMIC_MAX   2147483647
N
N    /* limit of size_t */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define SIZE_MAX UINT64_MAX
N#else
N#define SIZE_MAX UINT32_MAX
N#endif
N
N    /* limits of wchar_t */
N    /* NB we have to undef and redef because they're defined in both
N     * stdint.h and wchar.h */
N#undef WCHAR_MIN
N#undef WCHAR_MAX
N
N#if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
X#if 0L || (0L && __ARM_SIZEOF_WCHAR_T == 4)
S  #define WCHAR_MIN   0
S  #define WCHAR_MAX   0xffffffffU
N#else
N  #define WCHAR_MIN   0
N  #define WCHAR_MAX   65535
N#endif
N
N    /* limits of wint_t */
N#define WINT_MIN (~0x7fffffff)
N#define WINT_MAX 2147483647
N
N#endif /* __STDC_LIMIT_MACROS */
N
N#if !defined(__cplusplus) || defined(__STDC_CONSTANT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.4.1 macros for minimum-width integer constants */
N#define INT8_C(x)   (x)
N#define INT16_C(x)  (x)
N#define INT32_C(x)  (x)
N#define INT64_C(x)  __INT64_C(x)
N
N#define UINT8_C(x)  (x ## u)
N#define UINT16_C(x) (x ## u)
N#define UINT32_C(x) (x ## u)
N#define UINT64_C(x) __UINT64_C(x)
N
N    /* 7.18.4.2 macros for greatest-width integer constants */
N#define INTMAX_C(x)  __ESCAPE__(x ## ll)
N#define UINTMAX_C(x) __ESCAPE__(x ## ull)
N
N#endif /* __STDC_CONSTANT_MACROS */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDINT_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STDINT_NO_EXPORTS
S      using ::std::int8_t;
S      using ::std::int16_t;
S      using ::std::int32_t;
S      using ::std::int64_t;
S      using ::std::uint8_t;
S      using ::std::uint16_t;
S      using ::std::uint32_t;
S      using ::std::uint64_t;
S      using ::std::int_least8_t;
S      using ::std::int_least16_t;
S      using ::std::int_least32_t;
S      using ::std::int_least64_t;
S      using ::std::uint_least8_t;
S      using ::std::uint_least16_t;
S      using ::std::uint_least32_t;
S      using ::std::uint_least64_t;
S      using ::std::int_fast8_t;
S      using ::std::int_fast16_t;
S      using ::std::int_fast32_t;
S      using ::std::int_fast64_t;
S      using ::std::uint_fast8_t;
S      using ::std::uint_fast16_t;
S      using ::std::uint_fast32_t;
S      using ::std::uint_fast64_t;
S      using ::std::intptr_t;
S      using ::std::uintptr_t;
S      using ::std::intmax_t;
S      using ::std::uintmax_t;
S    #endif
N  #endif /* __cplusplus */
N
N#undef __INT64
N#undef __LONGLONG
N
N#endif /* __stdint_h */
N
N/* end of stdint.h */
L 14 "app\bim_intc.h" 2
N#include "compiler.h"   
L 1 "..\..\sdk\plactform\arch\compiler\compiler.h" 1
N/**
N ****************************************************************************************
N *
N * @file gnuarm/compiler.h
N *
N * @brief Definitions of compiler specific directives.
N *
N * Copyright (C) RivieraWaves 2009-2015
N *
N *
N ****************************************************************************************
N */
N
N#ifndef _COMPILER_H_
N#define _COMPILER_H_
N
N
N/// define the static keyword for this compiler
N#define __STATIC static
N
N/// define the force inlining attribute for this compiler
N//#define __INLINE static __attribute__((__always_inline__)) inline
N	
N/// define the force inlining attribute for this compiler
N#define __INLINE                   __forceinline static
N#define inline        
N
N/// define the IRQ handler attribute for this compiler
N//#define __IRQ __attribute__((__interrupt__("IRQ")))
N#define __IRQ                      __irq
N
N/// define the BLE IRQ handler attribute for this compiler
N#define __BTIRQ
N
N/// define the BLE IRQ handler attribute for this compiler
N#define __BLEIRQ
N
N/// define the FIQ handler attribute for this compiler
N//#define __FIQ __attribute__((__interrupt__("FIQ")))
N#define __FIQ                      __irq
N/// define size of an empty array (used to declare structure with an array size not defined)
N#define __ARRAY_EMPTY
N
N/// Function returns struct in registers (4 in rvds, var with gnuarm).
N/// With Gnuarm, feature depends on command line options and
N/// impacts ALL functions returning 2-words max structs
N/// (check -freg-struct-return and -mabi=xxx)
N#define __VIR
N
N/// function has no side effect and return depends only on arguments
N#define __PURE __attribute__((const))
N
N/// Align instantiated lvalue or struct member on 4 bytes
N#define __ALIGN4 __attribute__((aligned(4))) 
N
N/// __MODULE__ comes from the RVDS compiler that supports it
N//#define __MODULE__ 				__BASE_FILE__
N
N/// Pack a structure field
N#define __PACKED __attribute__ ((__packed__))
N
N/// Put a variable in a memory maintained during deep sleep
N#define __LOWPOWER_SAVED
N
N#endif // _COMPILER_H_
L 15 "app\bim_intc.h" 2
N#include "BK3432_reg.h"
L 1 "..\..\sdk\plactform\arch\BK3432_reg.h" 1
N
N#ifndef _BK3432_REG_H_
N#define _BK3432_REG_H_
N
N
N
N/////////////////////////////////////////////////////////////////////////////
N//memory layout
N/////////////////////////////////////////////////////////////////////////////
N#define ROM_START_ADDR           0x00000000
N#define RAM_START_ADDR           0x00400000
N
N#define AHB0_ICU_BASE            0x00800000
N#define AHB1_XVR_BASE            0x00801400
N#define AHB_FLASH_BASE					 0x00802000
N#define AHB6_AHB2APB_BASE        0x00806000
N#define AHB10_RW_REG_BASE        0x00810000
N#define AHB14_RW_EM_BASE         0x00814000
N
N#define APB0_WDT_BASE            0x00806000
N#define APB1_PWM_BASE            0x00806100
N#define APB2_SPI_BASE            0x00806200
N#define APB3_UART_BASE           0x00806300
N#define APB4_I2C_BASE            0x00806400
N#define APB5_GPIO_BASE           0x00806500
N#define APB6_RTC_BASE            0x00806600
N#define APB7_ADC_BASE            0x00806700
N
N#define APB_BLE_BASE             0x00802000 
N
N#define p_AHB0_ICU_BASE          (*((volatile unsigned long *)  0x00800000))
N#define p_AHB1_XVR_BASE          (*((volatile unsigned long *)  0x00801000))
N#define p_AHB3_MFC_BASE          (*((volatile unsigned long *)  0x00803000))
N#define p_AHB6_AHB2APB_BASE      (*((volatile unsigned long *)  0x00806000))
N#define p_AHB1_RW_REG_BASE      (*((volatile unsigned long *)  0x00810000))
N#define p_AHB1_RW_EM_BASE       (*((volatile unsigned long *)  0x00814000))
N    
N#define p_APB0_WDT_BASE          (*((volatile unsigned long *)  0x00806000))
N#define p_APB1_PWM_BASE          (*((volatile unsigned long *)  0x00806100))
N#define p_APB2_SPI_BASE          (*((volatile unsigned long *)  0x00806200))
N#define p_APB3_UART_BASE         (*((volatile unsigned long *)  0x00806300))
N#define p_APB4_I2C_BASE          (*((volatile unsigned long *)  0x00806400))
N#define p_APB5_GPIO_BASE         (*((volatile unsigned long *)  0x00806500))
N#define p_APB6_RTC_BASE          (*((volatile unsigned long *)  0x00806600))
N#define p_APB7_ADC_BASE          (*((volatile unsigned long *)  0x00806700))
N
N/////////////////////////////////////////////////////////////////////////////
N//register definition
N/////////////////////////////////////////////////////////////////////////////
N//ICU register definitions
N#define REG_AHB0_ICU_CLKSRCSEL             (*((volatile unsigned long *)   0x00800000))
N#define SET_CLK_SEL_32K                    0x0
N#define SET_CLK_SEL_16M                    0x1
N#define SET_CLK_SEL_48M                    0x3
N
N#define REG_AHB0_ICU_CORECLKCON            (*((volatile unsigned long *)   0x00800004))
N#define BIT_CORE_CLK_DIV                   1
N
N#define REG_AHB0_ICU_ADCCLKCON             (*((volatile unsigned long *)   0x00800008))
N#define REG_AHB0_ICU_UARTCLKCON            (*((volatile unsigned long *)   0x0080000c))
N#define REG_AHB0_ICU_I2CCLKCON             (*((volatile unsigned long *)   0x00800010))
N#define REG_AHB0_ICU_SPICLKCON             (*((volatile unsigned long *)   0x00800014))
N#define REG_AHB0_ICU_BLECLKCON             (*((volatile unsigned long *)   0x00800018))
N#define REG_AHB0_ICU_WDTCLKCON             (*((volatile unsigned long *)   0x0080001c))
N#define REG_AHB0_ICU_RNGCLKCON             (*((volatile unsigned long *)   0x00800020))
N#define REG_AHB0_ICU_PWMCLKCON             (*((volatile unsigned long *)   0x00800024))
N#define BIT_PWM_CLK_SEL                    1
N#define SET_PWM_CLK_SEL                    (0x1 << BIT_PWM_CLK_SEL)
N
N#define REG_AHB0_ICU_RTCCLKCON             (*((volatile unsigned long *)   0x00800028))
N
N#define REG_AHB0_ICU_LPO_CLK_ON            (*((volatile unsigned long *)   0x0080002C))
N
N#define REG_AHB0_ICU_CLK32K_SEL            (*((volatile unsigned long *)   0x00800030))
N
N#define REG_AHB0_ICU_ANA_CTL          	   (*((volatile unsigned long *)   0x00800034))
N#define REG_AHB0_ICU_CPU_STATUS            (*((volatile unsigned long *)   0x00800038))
N#define REG_AHB0_ICU_INT_ENABLE            (*((volatile unsigned long *)   0x00800040))
N#define REG_AHB0_ICU_IRQ_ENABLE            (*((volatile unsigned long *)   0x00800044))
N#define REG_AHB0_ICU_INT_FLAG              (*((volatile unsigned long *)   0x00800048))
N#define REG_AHB0_ICU_FLASH                 (*((volatile unsigned long *)   0x0080004c))
N#define REG_AHB0_ICU_ANALOG_MODE           (*((volatile unsigned long *)   0x00800050))
N#define REG_AHB0_ICU_ANALOG0_PWD           (*((volatile unsigned long *)   0x00800054))
N#define REG_AHB0_ICU_ANALOG1_PWD           (*((volatile unsigned long *)   0x00800058))
N#define REG_AHB0_ICU_DIGITAL_PWD           (*((volatile unsigned long *)   0x0080005c))
N
N#define REG_AHB0_ICU_TIME_COUNT           (*((volatile unsigned long *)   0x0080007C))
N
N
N
N
N//Digital PWD Bit
N#define BIT_ANA_TEST_PIN                   5
N#define BIT_BB_TEST_PIN                    4
N#define BIT_CLK16M_PWD                     3
N#define BIT_HP_LDO_PWD                     2
N#define BIT_CLK48M_PWD                     1
N#define BIT_CB_BAIS_PWD                    0
N#define SET_ANA_TEST_PIN                   (0x01 << BIT_ANA_TEST_PIN) 
N#define SET_BB_TEST_PIN                    (0x01 << BIT_BB_TEST_PIN) 
N#define SET_CLK16M_PWD                     (0x01 << BIT_CLK16M_PWD ) // 3
N#define SET_HP_LDO_PWD                     (0x01 << BIT_HP_LDO_PWD ) // 2
N#define SET_CLK48M_PWD                     (0x01 << BIT_CLK48M_PWD ) // 1
N#define SET_CB_BAIS_PWD                    (0x01 << BIT_CB_BAIS_PWD) // 0
N
N
N// DEEP_SLEEP0 is GPIO-A to GPIO-D deep sleep wake-en
N// DEEP_SLEEP1 is GPIO-E deep sleep wake-en and deep sleep word
N#define REG_AHB0_ICU_DEEP_SLEEP0           (*((volatile unsigned long *)   0x00800060))
N#define REG_AHB0_ICU_DEEP_SLEEP1           (*((volatile unsigned long *)   0x00800064))
N#define BIT_GPIOA_WAKE_EN                  0
N#define BIT_GPIOB_WAKE_EN                  8
N#define BIT_GPIOC_WAKE_EN                  16
N#define BIT_GPIOD_WAKE_EN                  24
N#define BIT_GPIOE_WAKE_EN                  0
N#define BIT_DEEP_SLEEP_WORD                16
N#define SET_DEEP_SLEEP_WORD                (0xFFFF << BIT_DEEP_SLEEP_WORD)
N
N#define REG_AHB0_ICU_RC32K_CONFG           (*((volatile unsigned long *)   0x00800068))
N#define REG_AHB0_ICU_SLEEP_TIME            (*((volatile unsigned long *)   0x0080006C))
N#define BIT_MANU_FIN                       8
N#define BIT_MANU_CIN                       3
N#define BIT_MANU_EN                        2
N#define BIT_CALI_MODE                      1
N#define BIT_SPI_TRIG                       0
N#define SET_MANU_FIN                       (0x1FF<< BIT_MANU_FIN )
N#define SET_MANU_CIN                       (0x1F << BIT_MANU_CIN )
N#define SET_MANU_EN                        (0x1  << BIT_MANU_EN  )
N#define SET_CALI_MODE                      (0x1  << BIT_CALI_MODE)
N#define SET_SPI_TRIG                       (0x1  << BIT_SPI_TRIG )
N
N
N
N//FIQ
N#define INT_STATUS_PWM0_bit     (0x01<<0)
N#define INT_STATUS_LBD_bit      (0x01<<10)
N#define INT_STATUS_BLE_bit      (0x01<<15)
N//IRQ
N#define INT_STATUS_UART1_bit     (0x01<< 16)
N#define INT_STATUS_RTC_bit      (0x01<<12)
N#define INT_STATUS_RNG_bit      (0x01<<11)
N#define INT_STATUS_GPIO_bit     (0x01<< 9)
N#define INT_STATUS_ADC_bit      (0x01<< 8)
N#define INT_STATUS_I2C_bit      (0x01<< 7)
N#define INT_STATUS_SPI_bit      (0x01<< 6)
N#define INT_STATUS_UART_bit     (0x01<< 5)
N#define INT_STATUS_PWM4_bit     (0x01<< 4)
N#define INT_STATUS_PWM3_bit     (0x01<< 3)
N#define INT_STATUS_PWM2_bit     (0x01<< 2)
N#define INT_STATUS_PWM1_bit     (0x01<< 1)
N
N#define INT_IRQ_BIT             (0x01<<0)
N#define FIQ_IRQ_BIT             (0x01<<1)
N
N//RF register definitions
N//=====================================================================================
N
N
N
N//=====================================================================================
N//MFC
N//=====================================================================================
N#define REG_AHB3_MFC_KEYWORD             (*((volatile unsigned long *)   0x00803000))
N#define REG_AHB3_MFC_CONTROL             (*((volatile unsigned long *)   0x00803004))
N#define REG_AHB3_MFC_ADDR                (*((volatile unsigned long *)   0x00803008))
N#define REG_AHB3_MFC_DATA                (*((volatile unsigned long *)   0x0080300C))
N#define REG_AHB3_MFC_WP0                 (*((volatile unsigned long *)   0x00803010))
N#define REG_AHB3_MFC_WP1                 (*((volatile unsigned long *)   0x00803014))
N#define REG_AHB3_MFC_WP2                 (*((volatile unsigned long *)   0x00803018))
N#define REG_AHB3_MFC_WP3                 (*((volatile unsigned long *)   0x0080301c))
N
N//// MFC INTRN ////
N#define MFC_CONTROL_READ                (0x00)
N#define MFC_CONTROL_WRITE               (0x01<<2)
N#define MFC_CONTROL_SECT_ERASE          (0x02<<2)
N#define MFC_CONTROL_BLOCK_ERASE         (0x03<<2)
N#define MFC_CONTROL_CHIP_ERASE          (0x07<<2)
N#define MFC_CONTROL_MAIN_SPACE          (0x00<<5)
N#define MFC_CONTROL_NVR_SPACE           (0x01<<5)
N#define MFC_CONTROL_RDN_SPACE           (0x02<<5)
N
N
N//WDT
N#define REG_APB0_WDT_CFG                (*((volatile unsigned long *)   0x00806000))
N
N
N//=====================================================================================
N//PWM
N//=====================================================================================
N#define REG_APB1_PWM_0                  (*((volatile unsigned long *)   0x00806100))
N#define REG_APB1_PWM_1                  (*((volatile unsigned long *)   0x00806104))
N#define REG_APB1_PWM_2                  (*((volatile unsigned long *)   0x00806108))
N#define REG_APB1_PWM_3                  (*((volatile unsigned long *)   0x0080610c))
N#define REG_APB1_PWM_4                  (*((volatile unsigned long *)   0x00806110))
N#define BIT_PWM_MODE_MIDDLE             0
N#define BIT_TIMER_MODE_START            16
N#define SET_TIMER_MODE_START            (0xFFFF << BIT_TIMER_MODE_START)
N
N#define REG_APB1_PWM_CFG                (*((volatile unsigned long *)   0x00806114))
N#define PT0_MODE_BIT                    0
N#define PT1_MODE_BIT                    1
N#define PT2_MODE_BIT                    2
N#define PT3_MODE_BIT                    3
N#define PT4_MODE_BIT                    4
N#define PT_ENABLE_BIT                   7
N#define PT_CLK_DIV_BIT                  8
N#define PT0_INT_FLAG                    (1<<16)
N#define PT1_INT_FLAG                    (1<<17)
N#define PT2_INT_FLAG                    (1<<18)
N#define PT3_INT_FLAG                    (1<<19)
N#define PT4_INT_FLAG                    (1<<20)
N#define SET_PT_CLK_DIV                  (0xF << PT_CLK_DIV_BIT)
N
N
N// PWM Test Firmware Definition
N#define BK_TIMER_MODE       0
N#define BK_PWM_MODE         1
N
N#define PWM_CLK_SEL32K      0
N#define PWM_CLK_SEL16M      1
N
N//=====================================================================================
N
N
N//SPI
N#define REG_APB2_SPI_CTRL               (*((volatile unsigned long *)   0x00806200))
N#define REG_APB2_SPI_STAT               (*((volatile unsigned long *)   0x00806204))
N#define REG_APB2_SPI_DAT                (*((volatile unsigned long *)   0x00806208))
N
N//=====================================================================================
N// UART  
N//=====================================================================================
N#define REG_APB3_UART_CFG               (*((volatile unsigned long *)   0x00806300))
N#define REG_APB3_UART_FIFO_CFG          (*((volatile unsigned long *)   0x00806304))
N#define REG_APB3_UART_FIFO_STAT         (*((volatile unsigned long *)   0x00806308))
N#define REG_APB3_UART_PORT              (*((volatile unsigned long *)   0x0080630C))
N#define REG_APB3_UART_INT_ENABLE        (*((volatile unsigned long *)   0x00806310))
N#define REG_APB3_UART_INT_STAT          (*((volatile unsigned long *)   0x00806314))
N#define REG_APB3_UART_FLOW_CFG          (*((volatile unsigned long *)   0x00806318))
N#define REG_APB3_UART_WAKE_CFG          (*((volatile unsigned long *)   0x0080631c))
N
N
N
N
N#define BIT_UART_TX_ENABLE              0
N#define BIT_UART_RX_ENABLE              1
N#define BIT_UART_IRDA                   2
N#define BIT_UART_LEN                    3
N#define BIT_UART_PAR_EN                 5
N#define BIT_UART_PAR_MODE               6
N#define BIT_UART_STOP_LEN               7
N#define BIT_UART_CLK_DIVID              8
N#define SET_UART_TX_ENABLE              (0x1 << BIT_UART_TX_ENABLE)
N#define SET_UART_TX_DISABLE             (0x0 << BIT_UART_TX_ENABLE)
N#define SET_UART_RX_ENABLE              (0x1 << BIT_UART_RX_ENABLE)
N#define SET_UART_RX_DISABLE             (0x0 << BIT_UART_RX_ENABLE)
N#define SET_UART_IRDA                   (0x1 << BIT_UART_IRDA     )
N#define SET_UART_LEN                    (0x3 << BIT_UART_LEN      )
N#define SET_UART_PAR_EN                 (0x1 << BIT_UART_PAR_EN   )
N#define SET_UART_PAR_MODE               (0x1 << BIT_UART_PAR_MODE )
N#define SET_UART_STOP_LEN               (0x1 << BIT_UART_STOP_LEN )
N#define SET_UART_CLK_DIVID              (0x1FFF<<BIT_UART_CLK_DIVID)
N
N#define BIT_TX_FIFO_THRESHOLD           0
N#define BIT_RX_FIFO_THRESHOLD           8
N#define BIT_STOP_DETECT_TIME            16
N#define SET_TX_FIFO_THRESHOLD           (0xFF<< BIT_TX_FIFO_THRESHOLD)
N#define SET_RX_FIFO_THRESHOLD           (0xFF<< BIT_RX_FIFO_THRESHOLD)
N#define SET_STOP_DETECT_TIME            (0x3 << BIT_STOP_DETECT_TIME)
N
N
N#define BIT_TX_FIFO_COUNT               0
N#define BIT_RX_FIFO_COUNT               8
N#define SET_TX_FIFO_COUNT               (0xFF<< BIT_TX_FIFO_COUNT)
N#define SET_RX_FIFO_COUNT               (0xFF<< BIT_RX_FIFO_COUNT)
N
N#define BIT_UART_TX_FIFO_DIN            0
N#define BIT_UART_RX_FIFO_DOUT           8
N#define SET_UART_TX_FIFO_DIN            (0xFF<< BIT_UART_TX_FIFO_DIN )
N#define SET_UART_RX_FIFO_DOUT           (0xFF<< BIT_UART_RX_FIFO_DOUT)
N
N#define BIT_TX_FIFO_NEED_WRITE_EN       0
N#define BIT_RX_FIFO_NEED_READ_EN        1
N#define BIT_RX_FIFO_OVER_FLOW_EN        2
N#define BIT_UART_RX_PARITY_ERR_EN       3
N#define BIT_UART_RX_STOP_ERR_EN         4
N#define BIT_UART_TX_STOP_END_EN         5
N#define BIT_UART_RX_STOP_END_EN         6
N#define BIT_UART_RXD_WAKEUP_EN          7
N#define SET_TX_FIFO_NEED_WRITE_EN       (0x1 << BIT_TX_FIFO_NEED_WRITE_EN) 
N#define SET_RX_FIFO_NEED_READ_EN        (0x1 << BIT_RX_FIFO_NEED_READ_EN ) 
N#define SET_RX_FIFO_OVER_FLOW_EN        (0x1 << BIT_RX_FIFO_OVER_FLOW_EN ) 
N#define SET_UART_RX_PARITY_ERR_EN       (0x1 << BIT_UART_RX_PARITY_ERR_EN) 
N#define SET_UART_RX_STOP_ERR_EN         (0x1 << BIT_UART_RX_STOP_ERR_EN  ) 
N#define SET_UART_TX_STOP_END_EN         (0x1 << BIT_UART_TX_STOP_END_EN  ) 
N#define SET_UART_RX_STOP_END_EN         (0x1 << BIT_UART_RX_STOP_END_EN  ) 
N#define SET_UART_RXD_WAKEUP_EN          (0x1 << BIT_UART_RXD_WAKEUP_EN   ) 
N
N#define BIT_TX_FIFO_NEED_WRITE_FLAG     0
N#define BIT_RX_FIFO_NEED_READ_FLAG      1
N#define BIT_RX_FIFO_OVER_FLOW_FLAG      2
N#define BIT_UART_RX_PARITY_ERR_FLAG     3
N#define BIT_UART_RX_STOP_ERR_FLAG       4
N#define BIT_UART_TX_STOP_END_FLAG       5
N#define BIT_UART_RX_STOP_END_FLAG       6
N#define BIT_UART_RXD_WAKEUP_FLAG        7
N
N//=====================================================================================
N//=====================================================================================
N// UART2
N//=====================================================================================
N#define REG_APB3_UART2_CFG               (*((volatile unsigned long *)   0x00806a00))
N#define REG_APB3_UART2_FIFO_CFG          (*((volatile unsigned long *)   0x00806a04))
N#define REG_APB3_UART2_FIFO_STAT         (*((volatile unsigned long *)   0x00806a08))
N#define REG_APB3_UART2_PORT              (*((volatile unsigned long *)   0x00806a0C))
N#define REG_APB3_UART2_INT_ENABLE        (*((volatile unsigned long *)   0x00806a10))
N#define REG_APB3_UART2_INT_STAT          (*((volatile unsigned long *)   0x00806a14))
N#define REG_APB3_UART2_FLOW_CFG         (*((volatile unsigned long *)   0x00806a18))
N#define REG_APB3_UART2_WAKE_CFG         (*((volatile unsigned long *)   0x00806a1c))
N
N#define BIT_UART2_TX_ENABLE              0
N#define BIT_UART2_RX_ENABLE              1
N#define BIT_UART2_IRDA                   2
N#define BIT_UART2_LEN                    3
N#define BIT_UART2_PAR_EN                 5
N#define BIT_UART2_PAR_MODE               6
N#define BIT_UART2_STOP_LEN               7
N#define BIT_UART2_CLK_DIVID              8
N#define SET_UART2_TX_ENABLE              (0x1 << BIT_UART2_TX_ENABLE)
N#define SET_UART2_TX_DISABLE             (0x0 << BIT_UART2_TX_ENABLE)
N#define SET_UART2_RX_ENABLE              (0x1 << BIT_UART2_RX_ENABLE)
N#define SET_UART2_RX_DISABLE             (0x0 << BIT_UART2_RX_ENABLE)
N#define SET_UART2_IRDA                   (0x1 << BIT_UART2_IRDA     )
N#define SET_UART2_LEN                    (0x3 << BIT_UART2_LEN      )
N#define SET_UART2_PAR_EN                 (0x1 << BIT_UART2_PAR_EN   )
N#define SET_UART2_PAR_MODE               (0x1 << BIT_UART2_PAR_MODE )
N#define SET_UART2_STOP_LEN               (0x1 << BIT_UART2_STOP_LEN )
N#define SET_UART2_CLK_DIVID              (0x1FFF<<BIT_UART2_CLK_DIVID)
N
N#define BIT2_TX_FIFO_THRESHOLD           0
N#define BIT2_RX_FIFO_THRESHOLD           8
N#define BIT2_STOP_DETECT_TIME            16
N#define SET2_TX_FIFO_THRESHOLD           (0xFF<< BIT2_TX_FIFO_THRESHOLD)
N#define SET2_RX_FIFO_THRESHOLD           (0xFF<< BIT2_RX_FIFO_THRESHOLD)
N#define SET2_STOP_DETECT_TIME            (0x3 << BIT2_STOP_DETECT_TIME)
N
N
N#define BIT2_TX_FIFO_COUNT               0
N#define BIT2_RX_FIFO_COUNT               8
N#define SET2_TX_FIFO_COUNT               (0xFF<< BIT2_TX_FIFO_COUNT)
N#define SET2_RX_FIFO_COUNT               (0xFF<< BIT2_RX_FIFO_COUNT)
N
N#define BIT_UART2_TX_FIFO_DIN            0
N#define BIT_UART2_RX_FIFO_DOUT           8
N#define SET_UART2_TX_FIFO_DIN            (0xFF<< BIT_UART2_TX_FIFO_DIN )
N#define SET_UART2_RX_FIFO_DOUT           (0xFF<< BIT_UART2_RX_FIFO_DOUT)
N
N#define BIT2_TX_FIFO_NEED_WRITE_EN       0
N#define BIT2_RX_FIFO_NEED_READ_EN        1
N#define BIT2_RX_FIFO_OVER_FLOW_EN        2
N#define BIT_UART2_RX_PARITY_ERR_EN       3
N#define BIT_UART2_RX_STOP_ERR_EN         4
N#define BIT_UART2_TX_STOP_END_EN         5
N#define BIT_UART2_RX_STOP_END_EN         6
N#define BIT_UART2_RXD_WAKEUP_EN          7
N#define SET2_TX_FIFO_NEED_WRITE_EN       (0x1 << BIT2_TX_FIFO_NEED_WRITE_EN)
N#define SET2_RX_FIFO_NEED_READ_EN        (0x1 << BIT2_RX_FIFO_NEED_READ_EN )
N#define SET2_RX_FIFO_OVER_FLOW_EN        (0x1 << BIT2_RX_FIFO_OVER_FLOW_EN )
N#define SET_UART2_RX_PARITY_ERR_EN       (0x1 << BIT_UART2_RX_PARITY_ERR_EN)
N#define SET_UART2_RX_STOP_ERR_EN         (0x1 << BIT_UART2_RX_STOP_ERR_EN  )
N#define SET_UART2_TX_STOP_END_EN         (0x1 << BIT_UART2_TX_STOP_END_EN  )
N#define SET_UART2_RX_STOP_END_EN         (0x1 << BIT_UART2_RX_STOP_END_EN  )
N#define SET_UART2_RXD_WAKEUP_EN          (0x1 << BIT_UART2_RXD_WAKEUP_EN   )
N
N#define BIT2_TX_FIFO_NEED_WRITE_FLAG     0
N#define BIT2_RX_FIFO_NEED_READ_FLAG      1
N#define BIT2_RX_FIFO_OVER_FLOW_FLAG      2
N#define BIT_UART2_RX_PARITY_ERR_FLAG     3
N#define BIT_UART2_RX_STOP_ERR_FLAG       4
N#define BIT_UART2_TX_STOP_END_FLAG       5
N#define BIT_UART2_RX_STOP_END_FLAG       6
N#define BIT_UART2_RXD_WAKEUP_FLAG        7
N//=====================================================================================
N
N
N
N//IIC
N#define REG_APB4_I2C_CN                 (*((volatile unsigned long *)   0x00806400))
N#define REG_APB4_I2C_STAT               (*((volatile unsigned long *)   0x00806404))
N#define REG_APB4_I2C_DAT                (*((volatile unsigned long *)   0x00806408))
N
N#define I2C_INTR_BIT                    (0x01<<9)
N#define I2C_INTR_TX                     (0x01<<1)
N
N
N//=====================================================================================
N// GPIO
N//=====================================================================================
N#define REG_APB5_GPIOA_CFG              (*((volatile unsigned long *)   0x00806500))
N#define REG_APB5_GPIOA_DATA             (*((volatile unsigned long *)   0x00806504))
N#define REG_APB5_GPIOB_CFG              (*((volatile unsigned long *)   0x00806508))
N#define REG_APB5_GPIOB_DATA             (*((volatile unsigned long *)   0x0080650C))
N#define REG_APB5_GPIOC_CFG              (*((volatile unsigned long *)   0x00806510))
N#define REG_APB5_GPIOC_DATA             (*((volatile unsigned long *)   0x00806514))
N#define REG_APB5_GPIOD_CFG              (*((volatile unsigned long *)   0x00806518))
N#define REG_APB5_GPIOD_DATA             (*((volatile unsigned long *)   0x0080651C))
N#define REG_APB5_GPIOE_CFG              (*((volatile unsigned long *)   0x00806520))
N#define REG_APB5_GPIOE_DATA             (*((volatile unsigned long *)   0x00806524))
N                                                                            
N#define REG_APB5_GPIO_WUATOD_TYPE       (*((volatile unsigned long *)   0x00806540))
N#define REG_APB5_GPIO_WUE_TYPE          (*((volatile unsigned long *)   0x00806544))
N#define REG_APB5_GPIO_WUATOD_ENABLE     (*((volatile unsigned long *)   0x00806548))
N#define REG_APB5_GPIO_WUE_ENABLE        (*((volatile unsigned long *)   0x0080654C))
N#define REG_APB5_GPIO_WUATOD_STAT       (*((volatile unsigned long *)   0x00806550))
N#define REG_APB5_GPIO_WUE_STAT          (*((volatile unsigned long *)   0x00806554))
N
N#define BIT_GPIO_PERI_EN                0
N#define BIT_GPIO_OUT_EN_N               8
N#define BIT_GPIO_PULL_UP                16
N#define BIT_GPIO_PULL_DOWN              24
N#define BIT_GPIO_IN_BUFFER              0
N#define BIT_GPIO_OUT_BUFFER             8
N#define BIT_GPIO_INPUT_EN               16
N
N#define BIT_GPIOA_WU_TYPE               0
N#define BIT_GPIOB_WU_TYPE               8
N#define BIT_GPIOC_WU_TYPE               16
N#define BIT_GPIOD_WU_TYPE               24
N#define BIT_GPIOE_WU_TYPE               0
N
N
N//=====================================================================================
N//RTC
N//=====================================================================================
N#define REG_APB6_RTC_CFG                (*((volatile unsigned long *)   0x00806600))
N#define BIT_RTC_ENABLE                  0
N#define BIT_RTC_CLEAR                   1
N#define BIT_RTC_ALARM_EN                2
N#define BIT_RTC_ALARM_MODE              3
N#define SET_RTC_ENABLE                  (0x1 << BIT_RTC_ENABLE     )
N#define SET_RTC_CLEAR                   (0x1 << BIT_RTC_CLEAR      )
N#define SET_RTC_ALARM_EN                (0x1 << BIT_RTC_ALARM_EN   )
N#define SET_RTC_ALARM_MODE              (0x1 << BIT_RTC_ALARM_MODE )
N
N#define REG_APB6_RTC_UNIT               (*((volatile unsigned long *)   0x00806604))
N#define BIT_RTC_DIV                     0
N#define BIT_RTC_MSUNIT                  2
N#define BIT_RTC_SUNIT                   8
N#define SET_RTC_DIV                     (0x3    << BIT_RTC_DIV   )
N#define SET_RTC_MSUNIT                  (0x3F   << BIT_RTC_MSUNIT)
N#define SET_RTC_SUNIT                   (0xFFFF << BIT_RTC_SUNIT )
N
N#define REG_APB6_RTC_SET                (*((volatile unsigned long *)   0x00806608))
N#define BIT_RTC_SECOND                  0
N#define BIT_RTC_MINUTE                  6
N#define BIT_RTC_HOUR                    12
N#define BIT_RTC_WEEK                    17
N#define SET_RTC_SECOND                  (0x3F << BIT_RTC_SECOND )
N#define SET_RTC_MINUTE                  (0x3F << BIT_RTC_MINUTE )
N#define SET_RTC_HOUR                    (0x1F << BIT_RTC_HOUR   )
N#define SET_RTC_WEEK                    (0x7  << BIT_RTC_WEEK   )
N
N#define REG_APB6_RTC_ALM_TIME           (*((volatile unsigned long *)   0x0080660C))
N#define BIT_RTC_ALARM_SECOND            0
N#define BIT_RTC_ALARM_MINUTE            6
N#define BIT_RTC_ALARM_HOUR              12
N#define BIT_RTC_ALARM_MILLISEC          17
N#define SET_RTC_ALARM_SECOND            (0x3F  << BIT_RTC_ALARM_SECOND   )
N#define SET_RTC_ALARM_MINUTE            (0x3F  << BIT_RTC_ALARM_MINUTE   )
N#define SET_RTC_ALARM_HOUR              (0x1F  << BIT_RTC_ALARM_HOUR     )
N#define SET_RTC_ALARM_MILLISEC          (0x3FF << BIT_RTC_ALARM_MILLISEC )
N
N#define REG_APB6_RTC_ALM_FLAG           (*((volatile unsigned long *)   0x00806610))
N
N// RTC Test Firmware Definition
N#define BK_RTC_CLOCK_MODE         0
N#define BK_RTC_MILLISEC_MODE      1
N//=====================================================================================
N
N
N
N//====================================================================================
N// RND
N//====================================================================================
N#define REG_APB8_RND_CFG                (*((volatile unsigned long *)   0x00806900))
N#define REG_APB8_RND_DAT                (*((volatile unsigned long *)   0x00806904))
N
N
N//=====================================================================================
N// ADC                                   
N//=====================================================================================
N#define REG_APB7_ADC_CFG                (*((volatile unsigned long *)   0x00806700))
N#define REG_APB7_ADC_DAT                (*((volatile unsigned long *)   0x00806704))
N
N#define BIT_ADC_MODE                    0
N#define BIT_ADC_EN                      2
N#define BIT_ADC_CHNL                    3
N#define BIT_ADC_WAIT_CLK_SETTING        7
N#define BIT_ADC_INT_CLEAR               8
N#define BIT_ADC_PRE_DIV                 9
N#define BIT_ADC_DIV1_MODE				15
N#define BIT_ADC_SAMPLE_RATE             16
N#define BIT_ADC_FILTER             		22
N#define BIT_ADC_BUSY             		29
N
N#define BIT_ADC_FIFO_EMPTY              30
N#define BIT_ADC_FIFO_FULL               31
N
N#define SET_ADC_MODE                    (0x3 << BIT_ADC_MODE            )
N#define SET_ADC_EN                      (0x1 << BIT_ADC_EN              )
N#define SET_ADC_CHNL                    (0x7 << BIT_ADC_CHNL            )
N#define SET_ADC_FIFO_EMPTY              (0x1 << BIT_ADC_FIFO_EMPTY      )
N#define SET_ADC_FIFO_FULL               (0x1 << BIT_ADC_FIFO_FULL       )
N#define SET_ADC_SAMPLE_RATE             (0x3 << BIT_ADC_SAMPLE_RATE     )
N#define SET_ADC_WAIT_CLK_SETTING        (0x1 << BIT_ADC_WAIT_CLK_SETTING)
N#define SET_ADC_INT_CLEAR               (0x1 << BIT_ADC_INT_CLEAR       )
N
N//=====================================================================================
N
N
N
N
N//FLASH/RAM space (program)
N#define FLASH_ADDR0                     (*((volatile unsigned long *)   0x0000F000))
N#define FLASH_ADDR1                     (*((volatile unsigned long *)   0x0000F100))
N#define FLASH_ADDR2                     (*((volatile unsigned long *)   0x0000F200))
N#define FLASH_ADDR3                     (*((volatile unsigned long *)   0x0000F300))
N
N
N//===========================================================================================
N//XVR
N
N//===========================================================================================
N// Analog RF module + Transceiver Registers
N//===========================================================================================
N//Analog SPI Registers
N#define APB_XVER_BASE    0x00801400
N#define XVR_REG00               (*((volatile unsigned int *)   (APB_XVER_BASE+0x0)))
N#define XVR_REG01               (*((volatile unsigned int *)   (APB_XVER_BASE+0x4)))
N#define XVR_REG02               (*((volatile unsigned int *)   (APB_XVER_BASE+0x8)))
N#define XVR_REG03               (*((volatile unsigned int *)   (APB_XVER_BASE+0xC)))
N
N#define XVR_REG04               (*((volatile unsigned int *)   (APB_XVER_BASE+0x10)))
N#define XVR_REG05               (*((volatile unsigned int *)   (APB_XVER_BASE+0x14)))
N#define XVR_REG06               (*((volatile unsigned int *)   (APB_XVER_BASE+0x18)))
N#define XVR_REG07               (*((volatile unsigned int *)   (APB_XVER_BASE+0x1C)))
N
N#define XVR_REG08               (*((volatile unsigned int *)   (APB_XVER_BASE+0x20)))
N#define XVR_REG09               (*((volatile unsigned int *)   (APB_XVER_BASE+0x24)))
N#define XVR_REG0A               (*((volatile unsigned int *)   (APB_XVER_BASE+0x28)))
N#define XVR_REG0B               (*((volatile unsigned int *)   (APB_XVER_BASE+0x2C)))
N
N#define XVR_REG0C               (*((volatile unsigned int *)   (APB_XVER_BASE+0x30)))
N#define XVR_REG0D               (*((volatile unsigned int *)   (APB_XVER_BASE+0x34)))
N#define XVR_REG0E               (*((volatile unsigned int *)   (APB_XVER_BASE+0x38)))
N#define XVR_REG0F               (*((volatile unsigned int *)   (APB_XVER_BASE+0x3C)))
N
N// Read-Back Registers
N#define XVR_REG10                (*((volatile unsigned int *)   (APB_XVER_BASE+0x40)))
N#define XVR_REG11                (*((volatile unsigned int *)   (APB_XVER_BASE+0x44)))
N#define XVR_REG12                (*((volatile unsigned int *)   (APB_XVER_BASE+0x48)))
N#define XVR_REG13                (*((volatile unsigned int *)   (APB_XVER_BASE+0x4C)))
N
N#define XVR_REG14                (*((volatile unsigned int *)   (APB_XVER_BASE+0x50)))
N#define XVR_REG15                (*((volatile unsigned int *)   (APB_XVER_BASE+0x54)))
N#define XVR_REG16                (*((volatile unsigned int *)   (APB_XVER_BASE+0x58)))
N#define XVR_REG17                (*((volatile unsigned int *)   (APB_XVER_BASE+0x5C)))
N
N#define XVR_REG18                (*((volatile unsigned int *)   (APB_XVER_BASE+0x60)))
N#define XVR_REG19                (*((volatile unsigned int *)   (APB_XVER_BASE+0x64)))
N#define XVR_REG1A                (*((volatile unsigned int *)   (APB_XVER_BASE+0x68)))
N#define XVR_REG1B                (*((volatile unsigned int *)   (APB_XVER_BASE+0x6C)))
N
N#define XVR_REG1C                (*((volatile unsigned int *)   (APB_XVER_BASE+0x70)))
N#define XVR_REG1D                (*((volatile unsigned int *)   (APB_XVER_BASE+0x74)))
N#define XVR_REG1E                (*((volatile unsigned int *)   (APB_XVER_BASE+0x78)))
N#define XVR_REG1F                (*((volatile unsigned int *)   (APB_XVER_BASE+0x7C)))
N
N// XVR Config Registers 
N#define XVR_REG20                      (*((volatile unsigned int *)   (APB_XVER_BASE+0x80)))
N#define XVR_REG21                      (*((volatile unsigned int *)   (APB_XVER_BASE+0x84)))
N#define XVR_REG22                      (*((volatile unsigned int *)   (APB_XVER_BASE+0x88)))
N#define XVR_REG23                      (*((volatile unsigned int *)   (APB_XVER_BASE+0x8C)))
N
N#define XVR_REG24                      (*((volatile unsigned int *)   (APB_XVER_BASE+0x90)))
N#define XVR_REG25                      (*((volatile unsigned int *)   (APB_XVER_BASE+0x94)))
N#define XVR_REG26                      (*((volatile unsigned int *)   (APB_XVER_BASE+0x98)))
N#define XVR_REG27                      (*((volatile unsigned int *)   (APB_XVER_BASE+0x9C)))
N
N#define XVR_REG28                      (*((volatile unsigned int *)   (APB_XVER_BASE+0xA0)))
N#define XVR_REG29                      (*((volatile unsigned int *)   (APB_XVER_BASE+0xA4)))
N#define XVR_REG2A                      (*((volatile unsigned int *)   (APB_XVER_BASE+0xA8)))
N#define XVR_REG2B                      (*((volatile unsigned int *)   (APB_XVER_BASE+0xAC)))
N
N#define XVR_REG2C                      (*((volatile unsigned int *)   (APB_XVER_BASE+0xB0)))
N#define XVR_REG2D                      (*((volatile unsigned int *)   (APB_XVER_BASE+0xB4)))
N#define XVR_REG2E                      (*((volatile unsigned int *)   (APB_XVER_BASE+0xB8)))
N#define XVR_REG2F                      (*((volatile unsigned int *)   (APB_XVER_BASE+0xBC)))
N
N#define XVR_REG30                      (*((volatile unsigned int *)   (APB_XVER_BASE+0xC0)))
N#define XVR_REG31                      (*((volatile unsigned int *)   (APB_XVER_BASE+0xC4)))
N#define XVR_REG32                      (*((volatile unsigned int *)   (APB_XVER_BASE+0xC8)))
N#define XVR_REG33                      (*((volatile unsigned int *)   (APB_XVER_BASE+0xCC)))
N
N#define XVR_REG34                      (*((volatile unsigned int *)   (APB_XVER_BASE+0xD0)))
N#define XVR_REG35                      (*((volatile unsigned int *)   (APB_XVER_BASE+0xD4)))
N#define XVR_REG36                      (*((volatile unsigned int *)   (APB_XVER_BASE+0xD8)))
N#define XVR_REG37                      (*((volatile unsigned int *)   (APB_XVER_BASE+0xDC)))
N
N#define XVR_REG38                      (*((volatile unsigned int *)   (APB_XVER_BASE+0xE0)))
N#define XVR_REG39                      (*((volatile unsigned int *)   (APB_XVER_BASE+0xE4)))
N#define XVR_REG3A                      (*((volatile unsigned int *)   (APB_XVER_BASE+0xE8)))
N#define XVR_REG3B                      (*((volatile unsigned int *)   (APB_XVER_BASE+0xEC)))
N
N#define XVR_REG3C                      (*((volatile unsigned int *)   (APB_XVER_BASE+0xF0)))
N#define XVR_REG3D                      (*((volatile unsigned int *)   (APB_XVER_BASE+0xF4)))
N#define XVR_REG3E                      (*((volatile unsigned int *)   (APB_XVER_BASE+0xF8)))
N#define XVR_REG3F                      (*((volatile unsigned int *)   (APB_XVER_BASE+0xFC)))
N
N#define XVR_REG40                      (*((volatile unsigned int *)   (APB_XVER_BASE+0x100)))
N#define XVR_REG41                      (*((volatile unsigned int *)   (APB_XVER_BASE+0x104)))
N#define XVR_REG42                      (*((volatile unsigned int *)   (APB_XVER_BASE+0x108)))
N#define XVR_REG43                      (*((volatile unsigned int *)   (APB_XVER_BASE+0x10C)))
N
N#define XVR_REG44                      (*((volatile unsigned int *)   (APB_XVER_BASE+0x110)))
N#define XVR_REG45                      (*((volatile unsigned int *)   (APB_XVER_BASE+0x114)))
N#define XVR_REG46                      (*((volatile unsigned int *)   (APB_XVER_BASE+0x118)))
N#define XVR_REG47                      (*((volatile unsigned int *)   (APB_XVER_BASE+0x11C)))
N
N#define XVR_REG48                      (*((volatile unsigned int *)   (APB_XVER_BASE+0x120)))
N#define XVR_REG49                      (*((volatile unsigned int *)   (APB_XVER_BASE+0x124)))
N#define XVR_REG4A                      (*((volatile unsigned int *)   (APB_XVER_BASE+0x128)))
N#define XVR_REG4B                      (*((volatile unsigned int *)   (APB_XVER_BASE+0x12C)))
N
N#define XVR_REG4C                      (*((volatile unsigned int *)   (APB_XVER_BASE+0x130)))
N#define XVR_REG4D                      (*((volatile unsigned int *)   (APB_XVER_BASE+0x134)))
N#define XVR_REG4E                      (*((volatile unsigned int *)   (APB_XVER_BASE+0x138)))
N#define XVR_REG4F                      (*((volatile unsigned int *)   (APB_XVER_BASE+0x13C)))
N
N
N/// backup analog register
N//extern u_int32 backup_xvr_analog_reg[];
N#define mHWreg_Assign_XVR_Regsiter(No,Value) \
N    { \
N        XVR_REG##No = Value; \
N    }
X#define mHWreg_Assign_XVR_Regsiter(No,Value)     {         XVR_REG##No = Value;     }
N		
N
N#define REG_AHB1_XVER_BASE              (*((volatile unsigned long *)   0x00801488))
N
N#define BIT_AUTO_SYNCWORD               (0x1<<31)
N#define BIT_AUTO_SYNCWIN                (0x1<<30)
N#define BIT_AUTO_CHNN                   (0x1<<29)
N
N
N//RW////////////////////////////////////////////////////////////////////////////////
N#define REG_AHB10_RW_INT_MASK        (*((volatile unsigned long *)   0x0081000C))
N#define REG_AHB10_RW_INT_FLAG          (*((volatile unsigned long *)   0x00810010))
N#define REG_AHB10_RW_INT_FLAG_RAW          (*((volatile unsigned long *)   0x00810014))	
N#define REG_AHB10_RW_INT_ACK        (*((volatile unsigned long *)   0x00810018))
N#define REG_AHB10_RW_BASETIMECNT    (*((volatile unsigned long *)   0x0081001C))
N#define REG_AHB10_RW_DEEPSLCNTL     (*((volatile unsigned long *)   0x00810030))
N#define REG_AHB10_RW_DEEPSLTIME     (*((volatile unsigned long *)   0x00810034))
N#define REG_AHB10_RW_DEEPSLDUR     (*((volatile unsigned long *)   0x00810038))
N#define REG_AHB10_RW_ENBPRESET     (*((volatile unsigned long *)   0x0081003C))
N#define REG_AHB10_RW_FINECNTCORR     (*((volatile unsigned long *)   0x00810040))
N#define REG_AHB10_RW_BASETIMECNTCORR  (*((volatile unsigned long *)   0x00810044))
N#define REG_AHB10_RW_ERRORTYPESTAT    (*((volatile unsigned long *)   0x00810060))
N
N
N#define INT_RW_AUDIOINT2STAT_MASK      (0x01<<12)
N#define INT_RW_AUDIOINT1STAT_MASK      (0x01<<11)
N#define INT_RW_AUDIOINT0STAT_MASK      (0x01<< 10)
N#define INT_RW_SWINTSTAT_MASK          (0x01<< 9)
N#define INT_RW_EVENTAPFAINTSTAT_MASK      (0x01<< 8)
N#define INT_RW_FINETGTIMINTSTAT_MASK      (0x01<< 7)
N#define INT_RW_GROSSTGTIMINTSTAT_MASK     (0x01<< 6)
N#define INT_RW_ERRORINTSTAT_MASK     (0x01<< 5)
N#define INT_RW_CRYPTINTSTAT_MASK     (0x01<< 4)
N#define INT_RW_EVENTINTSTAT_MASK     (0x01<< 3)
N#define INT_RW_SLPINTSTAT_MASK       (0x01<< 2)
N#define INT_RW_RXINTSTAT_MASK        (0x01<< 1)
N#define INT_RW_CSCNTINTSTAT_MASK     (0x01<< 0)
N#define INT_RW_AUDIOINT2STAT_bit      (0x01<<12)
N#define INT_RW_AUDIOINT1STAT_bit      (0x01<<11)
N#define INT_RW_AUDIOINT0STAT_bit      (0x01<< 10)
N#define INT_RW_SWINTSTAT_bit          (0x01<< 9)
N#define INT_RW_EVENTAPFAINTSTAT_bit      (0x01<< 8)
N#define INT_RW_FINETGTIMINTSTAT_bit      (0x01<< 7)
N#define INT_RW_GROSSTGTIMINTSTAT_bit     (0x01<< 6)
N#define INT_RW_ERRORINTSTAT_bit     (0x01<< 5)
N#define INT_RW_CRYPTINTSTAT_bit     (0x01<< 4)
N#define INT_RW_EVENTINTSTAT_bit     (0x01<< 3)
N#define INT_RW_SLPINTSTAT_bit       (0x01<< 2)
N#define INT_RW_RXINTSTAT_bit        (0x01<< 1)
N#define INT_RW_CSCNTINTSTAT_bit     (0x01<< 0)
N
N#define RW_ENBPRESET_TWEXT_bit     21
N#define RW_ENBPRESET_TWOSC_bit     10
N#define RW_ENBPRESET_TWRW_bit     0
N
N#endif
N
L 16 "app\bim_intc.h" 2
N
N
N/*****************************************************/
N// 				don't change this !!!!!!!
N#define ISR_MAX_NUM  2
N#define ISR_FIQ_ISR_IDX  0
N#define ISR_IRQ_ISR_IDX  1
N
N#define ISR_MAX_NUM_PROTOCOL_USERS  19
N#define PWM0_FIQ_ISR_IDX								0
N#define PWM1_IRQ_ISR_IDX								1
N#define PWM2_IRQ_ISR_IDX								2
N#define PWM3_IRQ_ISR_IDX								3
N#define PWM4_IRQ_ISR_IDX								4
N
N#define UART_IRQ_ISR_IDX								5
N#define SPI_IRQ_ISR_IDX									6
N#define I2C_IRQ_ISR_IDX									7
N#define ADC_IRQ_ISR_IDX									8
N#define GPIO_IRQ_ISR_IDX								9
N#define RES_ISR_IDX0									10
N
N#define USB_IRQ_ISR_IDX									11
N#define RTC_IRQ_ISR_IDX									12
N#define PWM5_IRQ_ISR_IDX								13
N#define PWM_3DSIRQ_ISR_IDX								14
N#define BLE_FIQ_ISR_IDX									15
N#define UART2_IRQ_ISR_IDX								16
N#define SDM_IRQ_ISR_IDX								  	17
N#define I2S_IRQ_ISR_IDX									18
N
N/***************************************************/
L 15 "app\bim_intc.c" 2
N#include <string.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\string.h" 1
N/* string.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.11 */
N/* Copyright (C) Codemist Ltd., 1988-1993.                        */
N/* Copyright 1991-1993 ARM Limited. All rights reserved.          */
N/* version 0.04 */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N */
N
N/*
N * string.h declares one type and several functions, and defines one macro
N * useful for manipulating character arrays and other objects treated as
N * character arrays. Various methods are used for determining the lengths of
N * the arrays, but in all cases a char * or void * argument points to the
N * initial (lowest addresses) character of the array. If an array is written
N * beyond the end of an object, the behaviour is undefined.
N */
N
N#ifndef __string_h
N#define __string_h
N#define __ARMCLIB_VERSION 5060044
N
N#define _ARMABI __declspec(__nothrow)
N
N  #ifndef __STRING_DECLS
N  #define __STRING_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S        namespace std {
S        #define __CLIBNS std::
S        extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 0L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N#elif !defined(__size_t)
S  #define __size_t 1
S  #if __sizeof_ptr == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
S  #else
S    typedef unsigned int size_t;   /* see <stddef.h> */
S  #endif
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
Nextern _ARMABI void *memcpy(void * __restrict /*s1*/,
Xextern __declspec(__nothrow) void *memcpy(void * __restrict  ,
N                    const void * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies n characters from the object pointed to by s2 into the object
N    * pointed to by s1. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI void *memmove(void * /*s1*/,
Xextern __declspec(__nothrow) void *memmove(void *  ,
N                    const void * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies n characters from the object pointed to by s2 into the object
N    * pointed to by s1. Copying takes place as if the n characters from the
N    * object pointed to by s2 are first copied into a temporary array of n
N    * characters that does not overlap the objects pointed to by s1 and s2,
N    * and then the n characters from the temporary array are copied into the
N    * object pointed to by s1.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strcpy(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strcpy(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies the string pointed to by s2 (including the terminating nul
N    * character) into the array pointed to by s1. If copying takes place
N    * between objects that overlap, the behaviour is undefined.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strncpy(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strncpy(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies not more than n characters (characters that follow a null
N    * character are not copied) from the array pointed to by s2 into the array
N    * pointed to by s1. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: the value of s1.
N    */
N
Nextern _ARMABI char *strcat(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strcat(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * appends a copy of the string pointed to by s2 (including the terminating
N    * null character) to the end of the string pointed to by s1. The initial
N    * character of s2 overwrites the null character at the end of s1.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strncat(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strncat(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * appends not more than n characters (a null character and characters that
N    * follow it are not appended) from the array pointed to by s2 to the end of
N    * the string pointed to by s1. The initial character of s2 overwrites the
N    * null character at the end of s1. A terminating null character is always
N    * appended to the result.
N    * Returns: the value of s1.
N    */
N
N/*
N * The sign of a nonzero value returned by the comparison functions is
N * determined by the sign of the difference between the values of the first
N * pair of characters (both interpreted as unsigned char) that differ in the
N * objects being compared.
N */
N
Nextern _ARMABI int memcmp(const void * /*s1*/, const void * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int memcmp(const void *  , const void *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the first n characters of the object pointed to by s1 to the
N    * first n characters of the object pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the object pointed to by s1 is greater than, equal to, or
N    *          less than the object pointed to by s2.
N    */
Nextern _ARMABI int strcmp(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcmp(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strncmp(const char * /*s1*/, const char * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strncmp(const char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares not more than n characters (characters that follow a null
N    * character are not compared) from the array pointed to by s1 to the array
N    * pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strcasecmp(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcasecmp(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2,
N    * case-insensitively as defined by the current locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strncasecmp(const char * /*s1*/, const char * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strncasecmp(const char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares not more than n characters (characters that follow a null
N    * character are not compared) from the array pointed to by s1 to the array
N    * pointed to by s2, case-insensitively as defined by the current locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strcoll(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcoll(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2, both
N    * interpreted as appropriate to the LC_COLLATE category of the current
N    * locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2 when both are interpreted
N    *          as appropriate to the current locale.
N    */
N
Nextern _ARMABI size_t strxfrm(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) size_t strxfrm(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(2)));
N   /*
N    * transforms the string pointed to by s2 and places the resulting string
N    * into the array pointed to by s1. The transformation function is such that
N    * if the strcmp function is applied to two transformed strings, it returns
N    * a value greater than, equal to or less than zero, corresponding to the
N    * result of the strcoll function applied to the same two original strings.
N    * No more than n characters are placed into the resulting array pointed to
N    * by s1, including the terminating null character. If n is zero, s1 is
N    * permitted to be a null pointer. If copying takes place between objects
N    * that overlap, the behaviour is undefined.
N    * Returns: The length of the transformed string is returned (not including
N    *          the terminating null character). If the value returned is n or
N    *          more, the contents of the array pointed to by s1 are
N    *          indeterminate.
N    */
N
N
N#ifdef __cplusplus
Sextern _ARMABI const void *memchr(const void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Sextern "C++" void *memchr(void * __s, int __c, size_t __n) __attribute__((__nonnull__(1)));
Sextern "C++" inline void *memchr(void * __s, int __c, size_t __n)
S    { return const_cast<void *>(memchr(const_cast<const void *>(__s), __c, __n)); }
N#else
Nextern _ARMABI void *memchr(const void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void *memchr(const void *  , int  , size_t  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the first occurence of c (converted to an unsigned char) in the
N    * initial n characters (each interpreted as unsigned char) of the object
N    * pointed to by s.
N    * Returns: a pointer to the located character, or a null pointer if the
N    *          character does not occur in the object.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Sextern "C++" char *strchr(char * __s, int __c) __attribute__((__nonnull__(1)));
Sextern "C++" inline char *strchr(char * __s, int __c)
S    { return const_cast<char *>(strchr(const_cast<const char *>(__s), __c)); }
N#else
Nextern _ARMABI char *strchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *strchr(const char *  , int  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the first occurence of c (converted to an char) in the string
N    * pointed to by s (including the terminating null character).
N    * Returns: a pointer to the located character, or a null pointer if the
N    *          character does not occur in the string.
N    */
N
Nextern _ARMABI size_t strcspn(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strcspn(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * computes the length of the initial segment of the string pointed to by s1
N    * which consists entirely of characters not from the string pointed to by
N    * s2. The terminating null character is not considered part of s2.
N    * Returns: the length of the segment.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strpbrk(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Sextern "C++" char *strpbrk(char * __s1, const char * __s2) __attribute__((__nonnull__(1,2)));
Sextern "C++" inline char *strpbrk(char * __s1, const char * __s2)
S    { return const_cast<char *>(strpbrk(const_cast<const char *>(__s1), __s2)); }
N#else
Nextern _ARMABI char *strpbrk(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strpbrk(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N#endif
N   /*
N    * locates the first occurence in the string pointed to by s1 of any
N    * character from the string pointed to by s2.
N    * Returns: returns a pointer to the character, or a null pointer if no
N    *          character form s2 occurs in s1.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strrchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Sextern "C++" char *strrchr(char * __s, int __c) __attribute__((__nonnull__(1)));
Sextern "C++" inline char *strrchr(char * __s, int __c)
S    { return const_cast<char *>(strrchr(const_cast<const char *>(__s), __c)); }
N#else
Nextern _ARMABI char *strrchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *strrchr(const char *  , int  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the last occurence of c (converted to a char) in the string
N    * pointed to by s. The terminating null character is considered part of
N    * the string.
N    * Returns: returns a pointer to the character, or a null pointer if c does
N    *          not occur in the string.
N    */
N
Nextern _ARMABI size_t strspn(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strspn(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * computes the length of the initial segment of the string pointed to by s1
N    * which consists entirely of characters from the string pointed to by S2
N    * Returns: the length of the segment.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strstr(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Sextern "C++" char *strstr(char * __s1, const char * __s2) __attribute__((__nonnull__(1,2)));
Sextern "C++" inline char *strstr(char * __s1, const char * __s2)
S    { return const_cast<char *>(strstr(const_cast<const char *>(__s1), __s2)); }
N#else
Nextern _ARMABI char *strstr(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strstr(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N#endif
N   /*
N    * locates the first occurence in the string pointed to by s1 of the
N    * sequence of characters (excluding the terminating null character) in the
N    * string pointed to by s2.
N    * Returns: a pointer to the located string, or a null pointer if the string
N    *          is not found.
N    */
N
Nextern _ARMABI char *strtok(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) char *strtok(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(2)));
Nextern _ARMABI char *_strtok_r(char * /*s1*/, const char * /*s2*/, char ** /*ptr*/) __attribute__((__nonnull__(2,3)));
Xextern __declspec(__nothrow) char *_strtok_r(char *  , const char *  , char **  ) __attribute__((__nonnull__(2,3)));
N#ifndef __STRICT_ANSI__
Nextern _ARMABI char *strtok_r(char * /*s1*/, const char * /*s2*/, char ** /*ptr*/) __attribute__((__nonnull__(2,3)));
Xextern __declspec(__nothrow) char *strtok_r(char *  , const char *  , char **  ) __attribute__((__nonnull__(2,3)));
N#endif
N   /*
N    * A sequence of calls to the strtok function breaks the string pointed to
N    * by s1 into a sequence of tokens, each of which is delimited by a
N    * character from the string pointed to by s2. The first call in the
N    * sequence has s1 as its first argument, and is followed by calls with a
N    * null pointer as their first argument. The separator string pointed to by
N    * s2 may be different from call to call.
N    * The first call in the sequence searches for the first character that is
N    * not contained in the current separator string s2. If no such character
N    * is found, then there are no tokens in s1 and the strtok function returns
N    * a null pointer. If such a character is found, it is the start of the
N    * first token.
N    * The strtok function then searches from there for a character that is
N    * contained in the current separator string. If no such character is found,
N    * the current token extends to the end of the string pointed to by s1, and
N    * subsequent searches for a token will fail. If such a character is found,
N    * it is overwritten by a null character, which terminates the current
N    * token. The strtok function saves a pointer to the following character,
N    * from which the next search for a token will start.
N    * Each subsequent call, with a null pointer as the value for the first
N    * argument, starts searching from the saved pointer and behaves as
N    * described above.
N    * Returns: pointer to the first character of a token, or a null pointer if
N    *          there is no token.
N    *
N    * strtok_r() is a common extension which works exactly like
N    * strtok(), but instead of storing its state in a hidden
N    * library variable, requires the user to pass in a pointer to a
N    * char * variable which will be used instead. Any sequence of
N    * calls to strtok_r() passing the same char ** pointer should
N    * behave exactly like the corresponding sequence of calls to
N    * strtok(). This means that strtok_r() can safely be used in
N    * multi-threaded programs, and also that you can tokenise two
N    * strings in parallel.
N    */
N
Nextern _ARMABI void *memset(void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void *memset(void *  , int  , size_t  ) __attribute__((__nonnull__(1)));
N   /*
N    * copies the value of c (converted to an unsigned char) into each of the
N    * first n charactes of the object pointed to by s.
N    * Returns: the value of s.
N    */
Nextern _ARMABI char *strerror(int /*errnum*/);
Xextern __declspec(__nothrow) char *strerror(int  );
N   /*
N    * maps the error number in errnum to an error message string.
N    * Returns: a pointer to the string, the contents of which are
N    *          implementation-defined. The array pointed to shall not be
N    *          modified by the program, but may be overwritten by a
N    *          subsequent call to the strerror function.
N    */
Nextern _ARMABI size_t strlen(const char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) size_t strlen(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * computes the length of the string pointed to by s.
N    * Returns: the number of characters that precede the terminating null
N    *          character.
N    */
N
Nextern _ARMABI size_t strlcpy(char * /*dst*/, const char * /*src*/, size_t /*len*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strlcpy(char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies the string src into the string dst, using no more than
N    * len bytes of dst. Always null-terminates dst _within the
N    * length len (i.e. will copy at most len-1 bytes of string plus
N    * a NUL), unless len is actually zero.
N    * 
N    * Return value is the length of the string that _would_ have
N    * been written, i.e. the length of src. Thus, the operation
N    * succeeded without truncation if and only if ret < len;
N    * otherwise, the value in ret tells you how big to make dst if
N    * you decide to reallocate it. (That value does _not_ include
N    * the NUL.)
N    * 
N    * This is a BSD-derived library extension, which we are
N    * permitted to declare in a standard header because ISO defines
N    * function names beginning with 'str' as reserved for future
N    * expansion of <string.h>.
N    */
N
Nextern _ARMABI size_t strlcat(char * /*dst*/, const char * /*src*/, size_t /*len*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strlcat(char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * concatenates the string src to the string dst, using no more
N    * than len bytes of dst. Always null-terminates dst _within the
N    * length len (i.e. will copy at most len-1 bytes of string plus
N    * a NUL), unless len is actually zero.
N    * 
N    * Return value is the length of the string that _would_ have
N    * been written, i.e. the length of src plus the original length
N    * of dst. Thus, the operation succeeded without truncation if
N    * and only if ret < len; otherwise, the value in ret tells you
N    * how big to make dst if you decide to reallocate it. (That
N    * value does _not_ include the NUL.)
N    * 
N    * If no NUL is encountered within the first len bytes of dst,
N    * then the length of dst is considered to have been equal to
N    * len for the purposes of the return value (as if there were a
N    * NUL at dst[len]). Thus, the return value in this case is len
N    * + strlen(src).
N    * 
N    * This is a BSD-derived library extension, which we are
N    * permitted to declare in a standard header because ISO defines
N    * function names beginning with 'str' as reserved for future
N    * expansion of <string.h>.
N    */
N
Nextern _ARMABI void _membitcpybl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpybl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpybb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpybb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpyhl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpyhl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpyhb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpyhb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpywl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpywl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpywb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpywb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovebl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovebl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovebb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovebb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovehl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovehl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovehb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovehb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovewl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovewl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovewb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovewb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
N    /*
N     * Copies or moves a piece of memory from one place to another,
N     * with one-bit granularity. So you can start or finish a copy
N     * part way through a byte, and you can copy between regions
N     * with different alignment within a byte.
N     * 
N     * All these functions have the same prototype: two void *
N     * pointers for destination and source, then two integers
N     * giving the bit offset from those pointers, and finally the
N     * number of bits to copy.
N     * 
N     * Just like memcpy and memmove, the "cpy" functions copy as
N     * fast as they can in the assumption that the memory regions
N     * do not overlap, while the "move" functions cope correctly
N     * with overlap.
N     *
N     * Treating memory as a stream of individual bits requires
N     * defining a convention about what order those bits are
N     * considered to be arranged in. The above functions support
N     * multiple conventions:
N     * 
N     *  - the "bl" functions consider the unit of memory to be the
N     *    byte, and consider the bits within each byte to be
N     *    arranged in little-endian fashion, so that the LSB comes
N     *    first. (For example, membitcpybl(a,b,0,7,1) would copy
N     *    the MSB of the byte at b to the LSB of the byte at a.)
N     * 
N     *  - the "bb" functions consider the unit of memory to be the
N     *    byte, and consider the bits within each byte to be
N     *    arranged in big-endian fashion, so that the MSB comes
N     *    first.
N     * 
N     *  - the "hl" functions consider the unit of memory to be the
N     *    16-bit halfword, and consider the bits within each word
N     *    to be arranged in little-endian fashion.
N     * 
N     *  - the "hb" functions consider the unit of memory to be the
N     *    16-bit halfword, and consider the bits within each word
N     *    to be arranged in big-endian fashion.
N     * 
N     *  - the "wl" functions consider the unit of memory to be the
N     *    32-bit word, and consider the bits within each word to be
N     *    arranged in little-endian fashion.
N     * 
N     *  - the "wb" functions consider the unit of memory to be the
N     *    32-bit word, and consider the bits within each word to be
N     *    arranged in big-endian fashion.
N     */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STRING_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STRING_NO_EXPORTS
S      using ::std::size_t;
S      using ::std::memcpy;
S      using ::std::memmove;
S      using ::std::strcpy;
S      using ::std::strncpy;
S      using ::std::strcat;
S      using ::std::strncat;
S      using ::std::memcmp;
S      using ::std::strcmp;
S      using ::std::strncmp;
S      using ::std::strcasecmp;
S      using ::std::strncasecmp;
S      using ::std::strcoll;
S      using ::std::strxfrm;
S      using ::std::memchr;
S      using ::std::strchr;
S      using ::std::strcspn;
S      using ::std::strpbrk;
S      using ::std::strrchr;
S      using ::std::strspn;
S      using ::std::strstr;
S      using ::std::strtok;
S#ifndef __STRICT_ANSI__
S      using ::std::strtok_r;
S#endif
S      using ::std::_strtok_r;
S      using ::std::memset;
S      using ::std::strerror;
S      using ::std::strlen;
S      using ::std::strlcpy;
S      using ::std::strlcat;
S      using ::std::_membitcpybl;
S      using ::std::_membitcpybb;
S      using ::std::_membitcpyhl;
S      using ::std::_membitcpyhb;
S      using ::std::_membitcpywl;
S      using ::std::_membitcpywb;
S      using ::std::_membitmovebl;
S      using ::std::_membitmovebb;
S      using ::std::_membitmovehl;
S      using ::std::_membitmovehb;
S      using ::std::_membitmovewl;
S      using ::std::_membitmovewb;
S    #endif /* __STRING_NO_EXPORTS */
N  #endif /* __cplusplus */
N
N#endif
N
N/* end of string.h */
N
L 16 "app\bim_intc.c" 2
N#include "bim_uart.h"
L 1 "app\bim_uart.h" 1
N/**
N ****************************************************************************************
N *
N * @file bim_uart.h
N *
N * @brief UART Driver for HCI over UART operation.
N *
N * Copyright (C) Beken 2009-2015
N *
N *
N ****************************************************************************************
N */
N
N#ifndef _BIM_UART_H_
N#define _BIM_UART_H_
N
N/**
N ****************************************************************************************
N * @defgroup UART UART
N * @ingroup DRIVERS
N * @brief UART driver
N *
N * @{
N *
N ****************************************************************************************
N */
N
N/*
N * INCLUDE FILES
N ****************************************************************************************
N */
N#include <stdbool.h>          // standard boolean definitions
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\stdbool.h" 1
N/* stdbool.h: ISO/IEC 9899:1999 (C99), section 7.16 */
N
N/* Copyright (C) ARM Ltd., 2002
N * All rights reserved
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: drodgman $
N */
N
N#ifndef __bool_true_false_are_defined
N#define __bool_true_false_are_defined 1
N#define __ARMCLIB_VERSION 5060044
N
N  #ifndef __cplusplus /* In C++, 'bool', 'true' and 'false' and keywords */
N    #define bool _Bool
N    #define true 1
N    #define false 0
N  #else
S    #ifdef __GNUC__
S      /* GNU C++ supports direct inclusion of stdbool.h to provide C99
S         compatibility by defining _Bool */
S      #define _Bool bool
S    #endif
N  #endif
N
N#endif /* __bool_true_false_are_defined */
N
L 33 "app\bim_uart.h" 2
N#include <stdint.h>           // standard integer functions
N
N
N
N#if 0
S#define UART_PRINTF bim_uart_printf  
N#else
N#define UART_PRINTF bim_uart_printf_null 
N#endif // #if UART_PRINTF_EN
N 
N
N/*
N * ENUMERATION DEFINITIONS
N *****************************************************************************************
N */
N
N/*
N * FUNCTION DECLARATIONS
N ****************************************************************************************
N */
N
N/**
N ****************************************************************************************
N * @brief Initializes the UART to default values.
N *****************************************************************************************
N */
N
Ntypedef enum _UART_CMD_STATE
N{
N    
N    UART_CMD_STATE_HEAD,
N    UART_CMD_STATE_OPCODE_ONE,
N    UART_CMD_STATE_OPCODE_TWO,
N    UART_CMD_STATE_LENGTH,
N    UART_CMD_STATE_CMD,
N    UART_CMD_STATE_CMD_FLASH,
N    UART_CMD_STATE_LENGTH_FLASH_LEN0,
N    UART_CMD_STATE_LENGTH_FLASH_LEN1,
N    UART_CMD_STATE_LENGTH_FLASH_SCMD,
N    UART_CMD_STATE_PAYLOAD,
N    UART_CMD_STATE_ERROR_ONE,
N    UART_CMD_STATE_ERROR_TWO,
N    UART_CMD_STATE_ERROR_THREE,
N    UART_CMD_STATE_ERROR_FOUR,
N    UART_CMD_STATE_PACKET
N    
N} UART_CMD_STATE;
N
N#define LINK_CHECK_CMD     0X00
N#define CRC_CHECK_CMD      0X10
N#define SET_RESET_CMD      0X0E
N#define SET_BAUDRATE_CMD   0X0F
N#define STAY_ROM_CMD       0XAA
N
N
N
N
N#define BIM_UART0_RX_FIFO_MAX_COUNT  8196
N
N
N
N
N
N
N
N
Nvoid bim_uart_init(uint32_t baudrate);
N
Nvoid bim_dbg_initial(void);
N
Nvoid bim_uart_write( char *buff);
Nvoid bim_printf(char *title, uint32_t v, uint8_t radix) ;
Nint bim_dbg_putchar(char * st);
Nint bim_uart_putchar(char * st);
Nint bim_uart_printf(const char *fmt,...);
Nint bim_uart_printf_null(const char *fmt,...);
Nint bim_dbg_printf(const char *fmt,...);
Nvoid bim_uart_print_int(unsigned int num);
Nuint8_t bim_check_uart_stop(void);
N
Nvoid bim_cpu_delay( volatile unsigned int times);
Nvoid uart_cmd_dispath(uint8_t *buff,uint8_t len);
Nvoid cmd_response( uint8_t cmd, uint8_t length, uint8_t *payload );
Nvoid operate_flash_cmd_response( uint8_t cmd, uint8_t status,uint16_t length, uint8_t *payload );
Nvoid bim_uart_data_callback( uint8_t * buff, uint16_t len);
Nvoid bim_uart_isr(void);
Nvoid bim_uart_deinit( void );
N
N
N/// @} UART
N#endif /* _BIM_UART_H_ */
L 17 "app\bim_intc.c" 2
Ntypedef void (*FUNCPTR_T)(void);
N
Nextern void bim_wdt_enable(uint16_t wdt_cnt);
N
N
Nvoid Undefined_Exception(void)
N{
N    bim_wdt_enable(0X10);
N	while(1)
N	{
N		//UART_PRINTF("%s \r\n",__func__);
N		//uart_putchar("Undefined_Exception\r\n");
N	}
N
N}
Nvoid SoftwareInterrupt_Exception(void)
N{
N    bim_wdt_enable(0X10);
N	while(1)
N	{  
N		//UART_PRINTF("%s \r\n",__func__);
N		//uart_putchar("SoftwareInterrupt_Exception\r\n");
N	}
N
N}
Nvoid PrefetchAbort_Exception(void)
N{
N    bim_wdt_enable(0X10);
N	while(1)
N	{ 
N		//UART_PRINTF("%s \r\n",__func__);
N		//uart_putchar("PrefetchAbort_Exception\r\n");
N	}
N
N}
Nvoid DataAbort_Exception(void)
N{
N    bim_wdt_enable(0X10);
N	while(1)
N	{    
N		//UART_PRINTF("%s \r\n",__func__);
N		//uart_putchar("DataAbort_Exception\r\n");
N	}
N
N} 
N	
Nvoid Reserved_Exception(void)
N{
N    bim_wdt_enable(0X10);
N	while(1)
N	{ 
N		//UART_PRINTF("%s \r\n",__func__);
N		//uart_putchar("Reserved_Exception\r\n");
N	}
N
N}
N
N#pragma ARM
N__IRQ void Irq_Exception(void)
X__irq void Irq_Exception(void)
N{
N    uint32_t IntStat=REG_AHB0_ICU_INT_FLAG;
X    uint32_t IntStat=(*((volatile unsigned long *) 0x00800048));
N    
N    if(IntStat & INT_STATUS_UART_bit)
X    if(IntStat & (0x01<< 5))
N        bim_uart_isr();
N
N
N    REG_AHB0_ICU_INT_FLAG=IntStat;
X    (*((volatile unsigned long *) 0x00800048))=IntStat;
N
N}
N
N
N
