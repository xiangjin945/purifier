L 1 "app\bim_uart.c"
N#include <stddef.h>     // standard definition
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\stddef.h" 1
N/* stddef.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.1.4 */
N
N/* Copyright (C) ARM Ltd., 1999
N * All rights reserved
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: agrant $
N */
N
N/* Copyright (C) Codemist Ltd., 1988                            */
N/* Copyright 1991 ARM Limited. All rights reserved.             */
N/* version 0.05 */
N
N/*
N * The following types and macros are defined in several headers referred to in
N * the descriptions of the functions declared in that header. They are also
N * defined in this header file.
N */
N
N#ifndef __stddef_h
N#define __stddef_h
N#define __ARMCLIB_VERSION 5060044
N
N  #ifndef __STDDEF_DECLS
N  #define __STDDEF_DECLS
N    #undef __CLIBNS
N    #ifdef __cplusplus
S        namespace std {
S        #define __CLIBNS ::std::
S        extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N#if __sizeof_ptr == 8
X#if 4 == 8
S  typedef signed long ptrdiff_t;
N#else
N  typedef signed int ptrdiff_t;
N#endif
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 0L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N#elif !defined(__size_t)
S  #define __size_t 1
S  #if __sizeof_ptr == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
S  #else
S    typedef unsigned int size_t;   /* see <stddef.h> */
S  #endif
S   /* the unsigned integral type of the result of the sizeof operator. */
N#endif
N
N#ifndef __cplusplus  /* wchar_t is a builtin type for C++ */
N  #if !defined(__STRICT_ANSI__)
X  #if !0L
N  /* unconditional in non-strict C for consistency of debug info */
N    #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
X    #if 0L || (0L && __ARM_SIZEOF_WCHAR_T == 4)
S      typedef unsigned int wchar_t; /* also in <stdlib.h> and <inttypes.h> */
N    #else
N      typedef unsigned short wchar_t; /* also in <stdlib.h> and <inttypes.h> */
N    #endif
N  #elif !defined(__wchar_t)
S    #define __wchar_t 1
S    #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
S      typedef unsigned int wchar_t; /* also in <stdlib.h> and <inttypes.h> */
S    #else
S      typedef unsigned short wchar_t; /* also in <stdlib.h> and <inttypes.h> */
S    #endif
S   /*
S    * An integral type whose range of values can represent distinct codes for
S    * all members of the largest extended character set specified among the
S    * supported locales; the null character shall have the code value zero and
S    * each member of the basic character set shall have a code value when used
S    * as the lone character in an integer character constant.
S    */
N  #endif
N#endif
N
N#undef NULL  /* others (e.g. <stdio.h>) also define */
N#define NULL 0
N   /* null pointer constant. */
N
N#ifdef __clang__
S  #define offsetof(t, d) __builtin_offsetof(t, d)
N#else
N  /* EDG uses __INTADDR__ to avoid errors when strict */
N  #define offsetof(t, memb) ((__CLIBNS size_t)__INTADDR__(&(((t *)0)->memb)))
N#endif
N
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 201112L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 201112L <= 199901L) || (0L && 201103L <= __cplusplus)
N  typedef long double max_align_t;
N#endif
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDDEF_DECLS */
N
N
N  #ifdef __cplusplus
S    #ifndef __STDDEF_NO_EXPORTS
S      using ::std::size_t;
S      using ::std::ptrdiff_t;
S      #if !defined(__STRICT_ANSI__) || (defined(__cplusplus) && 201103L <= __cplusplus)
S        using ::std::max_align_t;
S      #endif
S    #endif 
N  #endif /* __cplusplus */
N
N#endif
N
N/* end of stddef.h */
N
L 2 "app\bim_uart.c" 2
N#include "timer.h"      // timer definition
L 1 "..\..\sdk\plactform\driver\timer\timer.h" 1
N/**
N ****************************************************************************************
N *
N * @file timer.h
N *
N * @brief TIMER Driver.
N *
N * Copyright (C) RivieraWaves 2009-2015
N *
N *
N ****************************************************************************************
N */
N
N#ifndef _TIMER_H_
N#define _TIMER_H_
N
N/**
N ****************************************************************************************
N * @defgroup TIMER
N * @ingroup DRIVERS
N *
N * @brief Timer driver
N *
N * @{
N *
N ****************************************************************************************
N */
N
N/*
N * INCLUDE FILES
N ****************************************************************************************
N */
N#include <stdint.h>      // standard integer definition
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\stdint.h" 1
N/* Copyright (C) ARM Ltd., 1999,2014 */
N/* All rights reserved */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: agrant $
N */
N
N#ifndef __stdint_h
N#define __stdint_h
N#define __ARMCLIB_VERSION 5060044
N
N  #ifdef __INT64_TYPE__
S    /* armclang predefines '__INT64_TYPE__' and '__INT64_C_SUFFIX__' */
S    #define __INT64 __INT64_TYPE__
N  #else
N    /* armcc has builtin '__int64' which can be used in --strict mode */
N    #define __INT64 __int64
N    #define __INT64_C_SUFFIX__ ll
N  #endif
N  #define __PASTE2(x, y) x ## y
N  #define __PASTE(x, y) __PASTE2(x, y)
N  #define __INT64_C(x)  __ESCAPE__(__PASTE(x, __INT64_C_SUFFIX__))
N  #define __UINT64_C(x)  __ESCAPE__(__PASTE(x ## u, __INT64_C_SUFFIX__))
N  #if defined(__clang__) || (defined(__ARMCC_VERSION) && !defined(__STRICT_ANSI__))
X  #if 0L || (1L && !0L)
N    /* armclang and non-strict armcc allow 'long long' in system headers */
N    #define __LONGLONG long long
N  #else
S    /* strict armcc has '__int64' */
S    #define __LONGLONG __int64
N  #endif
N
N  #ifndef __STDINT_DECLS
N  #define __STDINT_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N
N/*
N * 'signed' is redundant below, except for 'signed char' and if
N * the typedef is used to declare a bitfield.
N */
N
N    /* 7.18.1.1 */
N
N    /* exact-width signed integer types */
Ntypedef   signed          char int8_t;
Ntypedef   signed short     int int16_t;
Ntypedef   signed           int int32_t;
Ntypedef   signed       __INT64 int64_t;
Xtypedef   signed       __int64 int64_t;
N
N    /* exact-width unsigned integer types */
Ntypedef unsigned          char uint8_t;
Ntypedef unsigned short     int uint16_t;
Ntypedef unsigned           int uint32_t;
Ntypedef unsigned       __INT64 uint64_t;
Xtypedef unsigned       __int64 uint64_t;
N
N    /* 7.18.1.2 */
N
N    /* smallest type of at least n bits */
N    /* minimum-width signed integer types */
Ntypedef   signed          char int_least8_t;
Ntypedef   signed short     int int_least16_t;
Ntypedef   signed           int int_least32_t;
Ntypedef   signed       __INT64 int_least64_t;
Xtypedef   signed       __int64 int_least64_t;
N
N    /* minimum-width unsigned integer types */
Ntypedef unsigned          char uint_least8_t;
Ntypedef unsigned short     int uint_least16_t;
Ntypedef unsigned           int uint_least32_t;
Ntypedef unsigned       __INT64 uint_least64_t;
Xtypedef unsigned       __int64 uint_least64_t;
N
N    /* 7.18.1.3 */
N
N    /* fastest minimum-width signed integer types */
Ntypedef   signed           int int_fast8_t;
Ntypedef   signed           int int_fast16_t;
Ntypedef   signed           int int_fast32_t;
Ntypedef   signed       __INT64 int_fast64_t;
Xtypedef   signed       __int64 int_fast64_t;
N
N    /* fastest minimum-width unsigned integer types */
Ntypedef unsigned           int uint_fast8_t;
Ntypedef unsigned           int uint_fast16_t;
Ntypedef unsigned           int uint_fast32_t;
Ntypedef unsigned       __INT64 uint_fast64_t;
Xtypedef unsigned       __int64 uint_fast64_t;
N
N    /* 7.18.1.4 integer types capable of holding object pointers */
N#if __sizeof_ptr == 8
X#if 4 == 8
Stypedef   signed       __INT64 intptr_t;
Stypedef unsigned       __INT64 uintptr_t;
N#else
Ntypedef   signed           int intptr_t;
Ntypedef unsigned           int uintptr_t;
N#endif
N
N    /* 7.18.1.5 greatest-width integer types */
Ntypedef   signed     __LONGLONG intmax_t;
Xtypedef   signed     long long intmax_t;
Ntypedef unsigned     __LONGLONG uintmax_t;
Xtypedef unsigned     long long uintmax_t;
N
N
N#if !defined(__cplusplus) || defined(__STDC_LIMIT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.2.1 */
N
N    /* minimum values of exact-width signed integer types */
N#define INT8_MIN                   -128
N#define INT16_MIN                -32768
N#define INT32_MIN          (~0x7fffffff)   /* -2147483648 is unsigned */
N#define INT64_MIN  __INT64_C(~0x7fffffffffffffff) /* -9223372036854775808 is unsigned */
N
N    /* maximum values of exact-width signed integer types */
N#define INT8_MAX                    127
N#define INT16_MAX                 32767
N#define INT32_MAX            2147483647
N#define INT64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of exact-width unsigned integer types */
N#define UINT8_MAX                   255
N#define UINT16_MAX                65535
N#define UINT32_MAX           4294967295u
N#define UINT64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.2 */
N
N    /* minimum values of minimum-width signed integer types */
N#define INT_LEAST8_MIN                   -128
N#define INT_LEAST16_MIN                -32768
N#define INT_LEAST32_MIN          (~0x7fffffff)
N#define INT_LEAST64_MIN  __INT64_C(~0x7fffffffffffffff)
N
N    /* maximum values of minimum-width signed integer types */
N#define INT_LEAST8_MAX                    127
N#define INT_LEAST16_MAX                 32767
N#define INT_LEAST32_MAX            2147483647
N#define INT_LEAST64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of minimum-width unsigned integer types */
N#define UINT_LEAST8_MAX                   255
N#define UINT_LEAST16_MAX                65535
N#define UINT_LEAST32_MAX           4294967295u
N#define UINT_LEAST64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.3 */
N
N    /* minimum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MIN           (~0x7fffffff)
N#define INT_FAST16_MIN          (~0x7fffffff)
N#define INT_FAST32_MIN          (~0x7fffffff)
N#define INT_FAST64_MIN  __INT64_C(~0x7fffffffffffffff)
N
N    /* maximum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MAX             2147483647
N#define INT_FAST16_MAX            2147483647
N#define INT_FAST32_MAX            2147483647
N#define INT_FAST64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of fastest minimum-width unsigned integer types */
N#define UINT_FAST8_MAX            4294967295u
N#define UINT_FAST16_MAX           4294967295u
N#define UINT_FAST32_MAX           4294967295u
N#define UINT_FAST64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.4 */
N
N    /* minimum value of pointer-holding signed integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define INTPTR_MIN INT64_MIN
N#else
N#define INTPTR_MIN INT32_MIN
N#endif
N
N    /* maximum value of pointer-holding signed integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define INTPTR_MAX INT64_MAX
N#else
N#define INTPTR_MAX INT32_MAX
N#endif
N
N    /* maximum value of pointer-holding unsigned integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define UINTPTR_MAX UINT64_MAX
N#else
N#define UINTPTR_MAX UINT32_MAX
N#endif
N
N    /* 7.18.2.5 */
N
N    /* minimum value of greatest-width signed integer type */
N#define INTMAX_MIN  __ESCAPE__(~0x7fffffffffffffffll)
N
N    /* maximum value of greatest-width signed integer type */
N#define INTMAX_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum value of greatest-width unsigned integer type */
N#define UINTMAX_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.3 */
N
N    /* limits of ptrdiff_t */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define PTRDIFF_MIN INT64_MIN
S#define PTRDIFF_MAX INT64_MAX
N#else
N#define PTRDIFF_MIN INT32_MIN
N#define PTRDIFF_MAX INT32_MAX
N#endif
N
N    /* limits of sig_atomic_t */
N#define SIG_ATOMIC_MIN (~0x7fffffff)
N#define SIG_ATOMIC_MAX   2147483647
N
N    /* limit of size_t */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define SIZE_MAX UINT64_MAX
N#else
N#define SIZE_MAX UINT32_MAX
N#endif
N
N    /* limits of wchar_t */
N    /* NB we have to undef and redef because they're defined in both
N     * stdint.h and wchar.h */
N#undef WCHAR_MIN
N#undef WCHAR_MAX
N
N#if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
X#if 0L || (0L && __ARM_SIZEOF_WCHAR_T == 4)
S  #define WCHAR_MIN   0
S  #define WCHAR_MAX   0xffffffffU
N#else
N  #define WCHAR_MIN   0
N  #define WCHAR_MAX   65535
N#endif
N
N    /* limits of wint_t */
N#define WINT_MIN (~0x7fffffff)
N#define WINT_MAX 2147483647
N
N#endif /* __STDC_LIMIT_MACROS */
N
N#if !defined(__cplusplus) || defined(__STDC_CONSTANT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.4.1 macros for minimum-width integer constants */
N#define INT8_C(x)   (x)
N#define INT16_C(x)  (x)
N#define INT32_C(x)  (x)
N#define INT64_C(x)  __INT64_C(x)
N
N#define UINT8_C(x)  (x ## u)
N#define UINT16_C(x) (x ## u)
N#define UINT32_C(x) (x ## u)
N#define UINT64_C(x) __UINT64_C(x)
N
N    /* 7.18.4.2 macros for greatest-width integer constants */
N#define INTMAX_C(x)  __ESCAPE__(x ## ll)
N#define UINTMAX_C(x) __ESCAPE__(x ## ull)
N
N#endif /* __STDC_CONSTANT_MACROS */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDINT_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STDINT_NO_EXPORTS
S      using ::std::int8_t;
S      using ::std::int16_t;
S      using ::std::int32_t;
S      using ::std::int64_t;
S      using ::std::uint8_t;
S      using ::std::uint16_t;
S      using ::std::uint32_t;
S      using ::std::uint64_t;
S      using ::std::int_least8_t;
S      using ::std::int_least16_t;
S      using ::std::int_least32_t;
S      using ::std::int_least64_t;
S      using ::std::uint_least8_t;
S      using ::std::uint_least16_t;
S      using ::std::uint_least32_t;
S      using ::std::uint_least64_t;
S      using ::std::int_fast8_t;
S      using ::std::int_fast16_t;
S      using ::std::int_fast32_t;
S      using ::std::int_fast64_t;
S      using ::std::uint_fast8_t;
S      using ::std::uint_fast16_t;
S      using ::std::uint_fast32_t;
S      using ::std::uint_fast64_t;
S      using ::std::intptr_t;
S      using ::std::uintptr_t;
S      using ::std::intmax_t;
S      using ::std::uintmax_t;
S    #endif
N  #endif /* __cplusplus */
N
N#undef __INT64
N#undef __LONGLONG
N
N#endif /* __stdint_h */
N
N/* end of stdint.h */
L 34 "..\..\sdk\plactform\driver\timer\timer.h" 2
N#include <stdbool.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\stdbool.h" 1
N/* stdbool.h: ISO/IEC 9899:1999 (C99), section 7.16 */
N
N/* Copyright (C) ARM Ltd., 2002
N * All rights reserved
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: drodgman $
N */
N
N#ifndef __bool_true_false_are_defined
N#define __bool_true_false_are_defined 1
N#define __ARMCLIB_VERSION 5060044
N
N  #ifndef __cplusplus /* In C++, 'bool', 'true' and 'false' and keywords */
N    #define bool _Bool
N    #define true 1
N    #define false 0
N  #else
S    #ifdef __GNUC__
S      /* GNU C++ supports direct inclusion of stdbool.h to provide C99
S         compatibility by defining _Bool */
S      #define _Bool bool
S    #endif
N  #endif
N
N#endif /* __bool_true_false_are_defined */
N
L 35 "..\..\sdk\plactform\driver\timer\timer.h" 2
N/*
N * ENUMERATION DEFINITIONS
N *****************************************************************************************
N */
N#define HL_GROSSTARGET_MASK 0x00FFFFFF
N/*
N * FUNCTION DECLARATIONS
N ****************************************************************************************
N */
N
N/**
N ****************************************************************************************
N * @brief Initialize the timer1 as a count-down counter at 13MHz
N *
N ****************************************************************************************
N */
Nvoid timer_init(void);
N
N/**
N ****************************************************************************************
N * @brief Set when the timer should expires
N *
N * @param to timeout value
N *
N ****************************************************************************************
N */
Nvoid timer_set_timeout(uint32_t to);
N
N
N/**
N ****************************************************************************************
N * @brief control timer
N *
N * @param enable True to enable the timer, false to disable it
N *
N ****************************************************************************************
N */
Nvoid timer_enable(bool enable);
Xvoid timer_enable(_Bool enable);
N
N/**
N ****************************************************************************************
N * @brief Retrieve current time
N *
N * @return  current time in 10us step
N *
N ****************************************************************************************
N */
Nuint32_t timer_get_time(void);
N
N
N/// @} TIMER
N
N#endif /* _TIMER_H_ */
L 3 "app\bim_uart.c" 2
N#include "bim_uart.h"       // uart definition
L 1 "app\bim_uart.h" 1
N/**
N ****************************************************************************************
N *
N * @file bim_uart.h
N *
N * @brief UART Driver for HCI over UART operation.
N *
N * Copyright (C) Beken 2009-2015
N *
N *
N ****************************************************************************************
N */
N
N#ifndef _BIM_UART_H_
N#define _BIM_UART_H_
N
N/**
N ****************************************************************************************
N * @defgroup UART UART
N * @ingroup DRIVERS
N * @brief UART driver
N *
N * @{
N *
N ****************************************************************************************
N */
N
N/*
N * INCLUDE FILES
N ****************************************************************************************
N */
N#include <stdbool.h>          // standard boolean definitions
N#include <stdint.h>           // standard integer functions
N
N
N
N#if 0
S#define UART_PRINTF bim_uart_printf  
N#else
N#define UART_PRINTF bim_uart_printf_null 
N#endif // #if UART_PRINTF_EN
N 
N
N/*
N * ENUMERATION DEFINITIONS
N *****************************************************************************************
N */
N
N/*
N * FUNCTION DECLARATIONS
N ****************************************************************************************
N */
N
N/**
N ****************************************************************************************
N * @brief Initializes the UART to default values.
N *****************************************************************************************
N */
N
Ntypedef enum _UART_CMD_STATE
N{
N    
N    UART_CMD_STATE_HEAD,
N    UART_CMD_STATE_OPCODE_ONE,
N    UART_CMD_STATE_OPCODE_TWO,
N    UART_CMD_STATE_LENGTH,
N    UART_CMD_STATE_CMD,
N    UART_CMD_STATE_CMD_FLASH,
N    UART_CMD_STATE_LENGTH_FLASH_LEN0,
N    UART_CMD_STATE_LENGTH_FLASH_LEN1,
N    UART_CMD_STATE_LENGTH_FLASH_SCMD,
N    UART_CMD_STATE_PAYLOAD,
N    UART_CMD_STATE_ERROR_ONE,
N    UART_CMD_STATE_ERROR_TWO,
N    UART_CMD_STATE_ERROR_THREE,
N    UART_CMD_STATE_ERROR_FOUR,
N    UART_CMD_STATE_PACKET
N    
N} UART_CMD_STATE;
N
N#define LINK_CHECK_CMD     0X00
N#define CRC_CHECK_CMD      0X10
N#define SET_RESET_CMD      0X0E
N#define SET_BAUDRATE_CMD   0X0F
N#define STAY_ROM_CMD       0XAA
N
N
N
N
N#define BIM_UART0_RX_FIFO_MAX_COUNT  8196
N
N
N
N
N
N
N
N
Nvoid bim_uart_init(uint32_t baudrate);
N
Nvoid bim_dbg_initial(void);
N
Nvoid bim_uart_write( char *buff);
Nvoid bim_printf(char *title, uint32_t v, uint8_t radix) ;
Nint bim_dbg_putchar(char * st);
Nint bim_uart_putchar(char * st);
Nint bim_uart_printf(const char *fmt,...);
Nint bim_uart_printf_null(const char *fmt,...);
Nint bim_dbg_printf(const char *fmt,...);
Nvoid bim_uart_print_int(unsigned int num);
Nuint8_t bim_check_uart_stop(void);
N
Nvoid bim_cpu_delay( volatile unsigned int times);
Nvoid uart_cmd_dispath(uint8_t *buff,uint8_t len);
Nvoid cmd_response( uint8_t cmd, uint8_t length, uint8_t *payload );
Nvoid operate_flash_cmd_response( uint8_t cmd, uint8_t status,uint16_t length, uint8_t *payload );
Nvoid bim_uart_data_callback( uint8_t * buff, uint16_t len);
Nvoid bim_uart_isr(void);
Nvoid bim_uart_deinit( void );
N
N
N/// @} UART
N#endif /* _BIM_UART_H_ */
L 4 "app\bim_uart.c" 2
N#include "BK3432_reg.h"
L 1 "..\..\sdk\plactform\arch\BK3432_reg.h" 1
N
N#ifndef _BK3432_REG_H_
N#define _BK3432_REG_H_
N
N
N
N/////////////////////////////////////////////////////////////////////////////
N//memory layout
N/////////////////////////////////////////////////////////////////////////////
N#define ROM_START_ADDR           0x00000000
N#define RAM_START_ADDR           0x00400000
N
N#define AHB0_ICU_BASE            0x00800000
N#define AHB1_XVR_BASE            0x00801400
N#define AHB_FLASH_BASE					 0x00802000
N#define AHB6_AHB2APB_BASE        0x00806000
N#define AHB10_RW_REG_BASE        0x00810000
N#define AHB14_RW_EM_BASE         0x00814000
N
N#define APB0_WDT_BASE            0x00806000
N#define APB1_PWM_BASE            0x00806100
N#define APB2_SPI_BASE            0x00806200
N#define APB3_UART_BASE           0x00806300
N#define APB4_I2C_BASE            0x00806400
N#define APB5_GPIO_BASE           0x00806500
N#define APB6_RTC_BASE            0x00806600
N#define APB7_ADC_BASE            0x00806700
N
N#define APB_BLE_BASE             0x00802000 
N
N#define p_AHB0_ICU_BASE          (*((volatile unsigned long *)  0x00800000))
N#define p_AHB1_XVR_BASE          (*((volatile unsigned long *)  0x00801000))
N#define p_AHB3_MFC_BASE          (*((volatile unsigned long *)  0x00803000))
N#define p_AHB6_AHB2APB_BASE      (*((volatile unsigned long *)  0x00806000))
N#define p_AHB1_RW_REG_BASE      (*((volatile unsigned long *)  0x00810000))
N#define p_AHB1_RW_EM_BASE       (*((volatile unsigned long *)  0x00814000))
N    
N#define p_APB0_WDT_BASE          (*((volatile unsigned long *)  0x00806000))
N#define p_APB1_PWM_BASE          (*((volatile unsigned long *)  0x00806100))
N#define p_APB2_SPI_BASE          (*((volatile unsigned long *)  0x00806200))
N#define p_APB3_UART_BASE         (*((volatile unsigned long *)  0x00806300))
N#define p_APB4_I2C_BASE          (*((volatile unsigned long *)  0x00806400))
N#define p_APB5_GPIO_BASE         (*((volatile unsigned long *)  0x00806500))
N#define p_APB6_RTC_BASE          (*((volatile unsigned long *)  0x00806600))
N#define p_APB7_ADC_BASE          (*((volatile unsigned long *)  0x00806700))
N
N/////////////////////////////////////////////////////////////////////////////
N//register definition
N/////////////////////////////////////////////////////////////////////////////
N//ICU register definitions
N#define REG_AHB0_ICU_CLKSRCSEL             (*((volatile unsigned long *)   0x00800000))
N#define SET_CLK_SEL_32K                    0x0
N#define SET_CLK_SEL_16M                    0x1
N#define SET_CLK_SEL_48M                    0x3
N
N#define REG_AHB0_ICU_CORECLKCON            (*((volatile unsigned long *)   0x00800004))
N#define BIT_CORE_CLK_DIV                   1
N
N#define REG_AHB0_ICU_ADCCLKCON             (*((volatile unsigned long *)   0x00800008))
N#define REG_AHB0_ICU_UARTCLKCON            (*((volatile unsigned long *)   0x0080000c))
N#define REG_AHB0_ICU_I2CCLKCON             (*((volatile unsigned long *)   0x00800010))
N#define REG_AHB0_ICU_SPICLKCON             (*((volatile unsigned long *)   0x00800014))
N#define REG_AHB0_ICU_BLECLKCON             (*((volatile unsigned long *)   0x00800018))
N#define REG_AHB0_ICU_WDTCLKCON             (*((volatile unsigned long *)   0x0080001c))
N#define REG_AHB0_ICU_RNGCLKCON             (*((volatile unsigned long *)   0x00800020))
N#define REG_AHB0_ICU_PWMCLKCON             (*((volatile unsigned long *)   0x00800024))
N#define BIT_PWM_CLK_SEL                    1
N#define SET_PWM_CLK_SEL                    (0x1 << BIT_PWM_CLK_SEL)
N
N#define REG_AHB0_ICU_RTCCLKCON             (*((volatile unsigned long *)   0x00800028))
N
N#define REG_AHB0_ICU_LPO_CLK_ON            (*((volatile unsigned long *)   0x0080002C))
N
N#define REG_AHB0_ICU_CLK32K_SEL            (*((volatile unsigned long *)   0x00800030))
N
N#define REG_AHB0_ICU_ANA_CTL          	   (*((volatile unsigned long *)   0x00800034))
N#define REG_AHB0_ICU_CPU_STATUS            (*((volatile unsigned long *)   0x00800038))
N#define REG_AHB0_ICU_INT_ENABLE            (*((volatile unsigned long *)   0x00800040))
N#define REG_AHB0_ICU_IRQ_ENABLE            (*((volatile unsigned long *)   0x00800044))
N#define REG_AHB0_ICU_INT_FLAG              (*((volatile unsigned long *)   0x00800048))
N#define REG_AHB0_ICU_FLASH                 (*((volatile unsigned long *)   0x0080004c))
N#define REG_AHB0_ICU_ANALOG_MODE           (*((volatile unsigned long *)   0x00800050))
N#define REG_AHB0_ICU_ANALOG0_PWD           (*((volatile unsigned long *)   0x00800054))
N#define REG_AHB0_ICU_ANALOG1_PWD           (*((volatile unsigned long *)   0x00800058))
N#define REG_AHB0_ICU_DIGITAL_PWD           (*((volatile unsigned long *)   0x0080005c))
N
N#define REG_AHB0_ICU_TIME_COUNT           (*((volatile unsigned long *)   0x0080007C))
N
N
N
N
N//Digital PWD Bit
N#define BIT_ANA_TEST_PIN                   5
N#define BIT_BB_TEST_PIN                    4
N#define BIT_CLK16M_PWD                     3
N#define BIT_HP_LDO_PWD                     2
N#define BIT_CLK48M_PWD                     1
N#define BIT_CB_BAIS_PWD                    0
N#define SET_ANA_TEST_PIN                   (0x01 << BIT_ANA_TEST_PIN) 
N#define SET_BB_TEST_PIN                    (0x01 << BIT_BB_TEST_PIN) 
N#define SET_CLK16M_PWD                     (0x01 << BIT_CLK16M_PWD ) // 3
N#define SET_HP_LDO_PWD                     (0x01 << BIT_HP_LDO_PWD ) // 2
N#define SET_CLK48M_PWD                     (0x01 << BIT_CLK48M_PWD ) // 1
N#define SET_CB_BAIS_PWD                    (0x01 << BIT_CB_BAIS_PWD) // 0
N
N
N// DEEP_SLEEP0 is GPIO-A to GPIO-D deep sleep wake-en
N// DEEP_SLEEP1 is GPIO-E deep sleep wake-en and deep sleep word
N#define REG_AHB0_ICU_DEEP_SLEEP0           (*((volatile unsigned long *)   0x00800060))
N#define REG_AHB0_ICU_DEEP_SLEEP1           (*((volatile unsigned long *)   0x00800064))
N#define BIT_GPIOA_WAKE_EN                  0
N#define BIT_GPIOB_WAKE_EN                  8
N#define BIT_GPIOC_WAKE_EN                  16
N#define BIT_GPIOD_WAKE_EN                  24
N#define BIT_GPIOE_WAKE_EN                  0
N#define BIT_DEEP_SLEEP_WORD                16
N#define SET_DEEP_SLEEP_WORD                (0xFFFF << BIT_DEEP_SLEEP_WORD)
N
N#define REG_AHB0_ICU_RC32K_CONFG           (*((volatile unsigned long *)   0x00800068))
N#define REG_AHB0_ICU_SLEEP_TIME            (*((volatile unsigned long *)   0x0080006C))
N#define BIT_MANU_FIN                       8
N#define BIT_MANU_CIN                       3
N#define BIT_MANU_EN                        2
N#define BIT_CALI_MODE                      1
N#define BIT_SPI_TRIG                       0
N#define SET_MANU_FIN                       (0x1FF<< BIT_MANU_FIN )
N#define SET_MANU_CIN                       (0x1F << BIT_MANU_CIN )
N#define SET_MANU_EN                        (0x1  << BIT_MANU_EN  )
N#define SET_CALI_MODE                      (0x1  << BIT_CALI_MODE)
N#define SET_SPI_TRIG                       (0x1  << BIT_SPI_TRIG )
N
N
N
N//FIQ
N#define INT_STATUS_PWM0_bit     (0x01<<0)
N#define INT_STATUS_LBD_bit      (0x01<<10)
N#define INT_STATUS_BLE_bit      (0x01<<15)
N//IRQ
N#define INT_STATUS_UART1_bit     (0x01<< 16)
N#define INT_STATUS_RTC_bit      (0x01<<12)
N#define INT_STATUS_RNG_bit      (0x01<<11)
N#define INT_STATUS_GPIO_bit     (0x01<< 9)
N#define INT_STATUS_ADC_bit      (0x01<< 8)
N#define INT_STATUS_I2C_bit      (0x01<< 7)
N#define INT_STATUS_SPI_bit      (0x01<< 6)
N#define INT_STATUS_UART_bit     (0x01<< 5)
N#define INT_STATUS_PWM4_bit     (0x01<< 4)
N#define INT_STATUS_PWM3_bit     (0x01<< 3)
N#define INT_STATUS_PWM2_bit     (0x01<< 2)
N#define INT_STATUS_PWM1_bit     (0x01<< 1)
N
N#define INT_IRQ_BIT             (0x01<<0)
N#define FIQ_IRQ_BIT             (0x01<<1)
N
N//RF register definitions
N//=====================================================================================
N
N
N
N//=====================================================================================
N//MFC
N//=====================================================================================
N#define REG_AHB3_MFC_KEYWORD             (*((volatile unsigned long *)   0x00803000))
N#define REG_AHB3_MFC_CONTROL             (*((volatile unsigned long *)   0x00803004))
N#define REG_AHB3_MFC_ADDR                (*((volatile unsigned long *)   0x00803008))
N#define REG_AHB3_MFC_DATA                (*((volatile unsigned long *)   0x0080300C))
N#define REG_AHB3_MFC_WP0                 (*((volatile unsigned long *)   0x00803010))
N#define REG_AHB3_MFC_WP1                 (*((volatile unsigned long *)   0x00803014))
N#define REG_AHB3_MFC_WP2                 (*((volatile unsigned long *)   0x00803018))
N#define REG_AHB3_MFC_WP3                 (*((volatile unsigned long *)   0x0080301c))
N
N//// MFC INTRN ////
N#define MFC_CONTROL_READ                (0x00)
N#define MFC_CONTROL_WRITE               (0x01<<2)
N#define MFC_CONTROL_SECT_ERASE          (0x02<<2)
N#define MFC_CONTROL_BLOCK_ERASE         (0x03<<2)
N#define MFC_CONTROL_CHIP_ERASE          (0x07<<2)
N#define MFC_CONTROL_MAIN_SPACE          (0x00<<5)
N#define MFC_CONTROL_NVR_SPACE           (0x01<<5)
N#define MFC_CONTROL_RDN_SPACE           (0x02<<5)
N
N
N//WDT
N#define REG_APB0_WDT_CFG                (*((volatile unsigned long *)   0x00806000))
N
N
N//=====================================================================================
N//PWM
N//=====================================================================================
N#define REG_APB1_PWM_0                  (*((volatile unsigned long *)   0x00806100))
N#define REG_APB1_PWM_1                  (*((volatile unsigned long *)   0x00806104))
N#define REG_APB1_PWM_2                  (*((volatile unsigned long *)   0x00806108))
N#define REG_APB1_PWM_3                  (*((volatile unsigned long *)   0x0080610c))
N#define REG_APB1_PWM_4                  (*((volatile unsigned long *)   0x00806110))
N#define BIT_PWM_MODE_MIDDLE             0
N#define BIT_TIMER_MODE_START            16
N#define SET_TIMER_MODE_START            (0xFFFF << BIT_TIMER_MODE_START)
N
N#define REG_APB1_PWM_CFG                (*((volatile unsigned long *)   0x00806114))
N#define PT0_MODE_BIT                    0
N#define PT1_MODE_BIT                    1
N#define PT2_MODE_BIT                    2
N#define PT3_MODE_BIT                    3
N#define PT4_MODE_BIT                    4
N#define PT_ENABLE_BIT                   7
N#define PT_CLK_DIV_BIT                  8
N#define PT0_INT_FLAG                    (1<<16)
N#define PT1_INT_FLAG                    (1<<17)
N#define PT2_INT_FLAG                    (1<<18)
N#define PT3_INT_FLAG                    (1<<19)
N#define PT4_INT_FLAG                    (1<<20)
N#define SET_PT_CLK_DIV                  (0xF << PT_CLK_DIV_BIT)
N
N
N// PWM Test Firmware Definition
N#define BK_TIMER_MODE       0
N#define BK_PWM_MODE         1
N
N#define PWM_CLK_SEL32K      0
N#define PWM_CLK_SEL16M      1
N
N//=====================================================================================
N
N
N//SPI
N#define REG_APB2_SPI_CTRL               (*((volatile unsigned long *)   0x00806200))
N#define REG_APB2_SPI_STAT               (*((volatile unsigned long *)   0x00806204))
N#define REG_APB2_SPI_DAT                (*((volatile unsigned long *)   0x00806208))
N
N//=====================================================================================
N// UART  
N//=====================================================================================
N#define REG_APB3_UART_CFG               (*((volatile unsigned long *)   0x00806300))
N#define REG_APB3_UART_FIFO_CFG          (*((volatile unsigned long *)   0x00806304))
N#define REG_APB3_UART_FIFO_STAT         (*((volatile unsigned long *)   0x00806308))
N#define REG_APB3_UART_PORT              (*((volatile unsigned long *)   0x0080630C))
N#define REG_APB3_UART_INT_ENABLE        (*((volatile unsigned long *)   0x00806310))
N#define REG_APB3_UART_INT_STAT          (*((volatile unsigned long *)   0x00806314))
N#define REG_APB3_UART_FLOW_CFG          (*((volatile unsigned long *)   0x00806318))
N#define REG_APB3_UART_WAKE_CFG          (*((volatile unsigned long *)   0x0080631c))
N
N
N
N
N#define BIT_UART_TX_ENABLE              0
N#define BIT_UART_RX_ENABLE              1
N#define BIT_UART_IRDA                   2
N#define BIT_UART_LEN                    3
N#define BIT_UART_PAR_EN                 5
N#define BIT_UART_PAR_MODE               6
N#define BIT_UART_STOP_LEN               7
N#define BIT_UART_CLK_DIVID              8
N#define SET_UART_TX_ENABLE              (0x1 << BIT_UART_TX_ENABLE)
N#define SET_UART_TX_DISABLE             (0x0 << BIT_UART_TX_ENABLE)
N#define SET_UART_RX_ENABLE              (0x1 << BIT_UART_RX_ENABLE)
N#define SET_UART_RX_DISABLE             (0x0 << BIT_UART_RX_ENABLE)
N#define SET_UART_IRDA                   (0x1 << BIT_UART_IRDA     )
N#define SET_UART_LEN                    (0x3 << BIT_UART_LEN      )
N#define SET_UART_PAR_EN                 (0x1 << BIT_UART_PAR_EN   )
N#define SET_UART_PAR_MODE               (0x1 << BIT_UART_PAR_MODE )
N#define SET_UART_STOP_LEN               (0x1 << BIT_UART_STOP_LEN )
N#define SET_UART_CLK_DIVID              (0x1FFF<<BIT_UART_CLK_DIVID)
N
N#define BIT_TX_FIFO_THRESHOLD           0
N#define BIT_RX_FIFO_THRESHOLD           8
N#define BIT_STOP_DETECT_TIME            16
N#define SET_TX_FIFO_THRESHOLD           (0xFF<< BIT_TX_FIFO_THRESHOLD)
N#define SET_RX_FIFO_THRESHOLD           (0xFF<< BIT_RX_FIFO_THRESHOLD)
N#define SET_STOP_DETECT_TIME            (0x3 << BIT_STOP_DETECT_TIME)
N
N
N#define BIT_TX_FIFO_COUNT               0
N#define BIT_RX_FIFO_COUNT               8
N#define SET_TX_FIFO_COUNT               (0xFF<< BIT_TX_FIFO_COUNT)
N#define SET_RX_FIFO_COUNT               (0xFF<< BIT_RX_FIFO_COUNT)
N
N#define BIT_UART_TX_FIFO_DIN            0
N#define BIT_UART_RX_FIFO_DOUT           8
N#define SET_UART_TX_FIFO_DIN            (0xFF<< BIT_UART_TX_FIFO_DIN )
N#define SET_UART_RX_FIFO_DOUT           (0xFF<< BIT_UART_RX_FIFO_DOUT)
N
N#define BIT_TX_FIFO_NEED_WRITE_EN       0
N#define BIT_RX_FIFO_NEED_READ_EN        1
N#define BIT_RX_FIFO_OVER_FLOW_EN        2
N#define BIT_UART_RX_PARITY_ERR_EN       3
N#define BIT_UART_RX_STOP_ERR_EN         4
N#define BIT_UART_TX_STOP_END_EN         5
N#define BIT_UART_RX_STOP_END_EN         6
N#define BIT_UART_RXD_WAKEUP_EN          7
N#define SET_TX_FIFO_NEED_WRITE_EN       (0x1 << BIT_TX_FIFO_NEED_WRITE_EN) 
N#define SET_RX_FIFO_NEED_READ_EN        (0x1 << BIT_RX_FIFO_NEED_READ_EN ) 
N#define SET_RX_FIFO_OVER_FLOW_EN        (0x1 << BIT_RX_FIFO_OVER_FLOW_EN ) 
N#define SET_UART_RX_PARITY_ERR_EN       (0x1 << BIT_UART_RX_PARITY_ERR_EN) 
N#define SET_UART_RX_STOP_ERR_EN         (0x1 << BIT_UART_RX_STOP_ERR_EN  ) 
N#define SET_UART_TX_STOP_END_EN         (0x1 << BIT_UART_TX_STOP_END_EN  ) 
N#define SET_UART_RX_STOP_END_EN         (0x1 << BIT_UART_RX_STOP_END_EN  ) 
N#define SET_UART_RXD_WAKEUP_EN          (0x1 << BIT_UART_RXD_WAKEUP_EN   ) 
N
N#define BIT_TX_FIFO_NEED_WRITE_FLAG     0
N#define BIT_RX_FIFO_NEED_READ_FLAG      1
N#define BIT_RX_FIFO_OVER_FLOW_FLAG      2
N#define BIT_UART_RX_PARITY_ERR_FLAG     3
N#define BIT_UART_RX_STOP_ERR_FLAG       4
N#define BIT_UART_TX_STOP_END_FLAG       5
N#define BIT_UART_RX_STOP_END_FLAG       6
N#define BIT_UART_RXD_WAKEUP_FLAG        7
N
N//=====================================================================================
N//=====================================================================================
N// UART2
N//=====================================================================================
N#define REG_APB3_UART2_CFG               (*((volatile unsigned long *)   0x00806a00))
N#define REG_APB3_UART2_FIFO_CFG          (*((volatile unsigned long *)   0x00806a04))
N#define REG_APB3_UART2_FIFO_STAT         (*((volatile unsigned long *)   0x00806a08))
N#define REG_APB3_UART2_PORT              (*((volatile unsigned long *)   0x00806a0C))
N#define REG_APB3_UART2_INT_ENABLE        (*((volatile unsigned long *)   0x00806a10))
N#define REG_APB3_UART2_INT_STAT          (*((volatile unsigned long *)   0x00806a14))
N#define REG_APB3_UART2_FLOW_CFG         (*((volatile unsigned long *)   0x00806a18))
N#define REG_APB3_UART2_WAKE_CFG         (*((volatile unsigned long *)   0x00806a1c))
N
N#define BIT_UART2_TX_ENABLE              0
N#define BIT_UART2_RX_ENABLE              1
N#define BIT_UART2_IRDA                   2
N#define BIT_UART2_LEN                    3
N#define BIT_UART2_PAR_EN                 5
N#define BIT_UART2_PAR_MODE               6
N#define BIT_UART2_STOP_LEN               7
N#define BIT_UART2_CLK_DIVID              8
N#define SET_UART2_TX_ENABLE              (0x1 << BIT_UART2_TX_ENABLE)
N#define SET_UART2_TX_DISABLE             (0x0 << BIT_UART2_TX_ENABLE)
N#define SET_UART2_RX_ENABLE              (0x1 << BIT_UART2_RX_ENABLE)
N#define SET_UART2_RX_DISABLE             (0x0 << BIT_UART2_RX_ENABLE)
N#define SET_UART2_IRDA                   (0x1 << BIT_UART2_IRDA     )
N#define SET_UART2_LEN                    (0x3 << BIT_UART2_LEN      )
N#define SET_UART2_PAR_EN                 (0x1 << BIT_UART2_PAR_EN   )
N#define SET_UART2_PAR_MODE               (0x1 << BIT_UART2_PAR_MODE )
N#define SET_UART2_STOP_LEN               (0x1 << BIT_UART2_STOP_LEN )
N#define SET_UART2_CLK_DIVID              (0x1FFF<<BIT_UART2_CLK_DIVID)
N
N#define BIT2_TX_FIFO_THRESHOLD           0
N#define BIT2_RX_FIFO_THRESHOLD           8
N#define BIT2_STOP_DETECT_TIME            16
N#define SET2_TX_FIFO_THRESHOLD           (0xFF<< BIT2_TX_FIFO_THRESHOLD)
N#define SET2_RX_FIFO_THRESHOLD           (0xFF<< BIT2_RX_FIFO_THRESHOLD)
N#define SET2_STOP_DETECT_TIME            (0x3 << BIT2_STOP_DETECT_TIME)
N
N
N#define BIT2_TX_FIFO_COUNT               0
N#define BIT2_RX_FIFO_COUNT               8
N#define SET2_TX_FIFO_COUNT               (0xFF<< BIT2_TX_FIFO_COUNT)
N#define SET2_RX_FIFO_COUNT               (0xFF<< BIT2_RX_FIFO_COUNT)
N
N#define BIT_UART2_TX_FIFO_DIN            0
N#define BIT_UART2_RX_FIFO_DOUT           8
N#define SET_UART2_TX_FIFO_DIN            (0xFF<< BIT_UART2_TX_FIFO_DIN )
N#define SET_UART2_RX_FIFO_DOUT           (0xFF<< BIT_UART2_RX_FIFO_DOUT)
N
N#define BIT2_TX_FIFO_NEED_WRITE_EN       0
N#define BIT2_RX_FIFO_NEED_READ_EN        1
N#define BIT2_RX_FIFO_OVER_FLOW_EN        2
N#define BIT_UART2_RX_PARITY_ERR_EN       3
N#define BIT_UART2_RX_STOP_ERR_EN         4
N#define BIT_UART2_TX_STOP_END_EN         5
N#define BIT_UART2_RX_STOP_END_EN         6
N#define BIT_UART2_RXD_WAKEUP_EN          7
N#define SET2_TX_FIFO_NEED_WRITE_EN       (0x1 << BIT2_TX_FIFO_NEED_WRITE_EN)
N#define SET2_RX_FIFO_NEED_READ_EN        (0x1 << BIT2_RX_FIFO_NEED_READ_EN )
N#define SET2_RX_FIFO_OVER_FLOW_EN        (0x1 << BIT2_RX_FIFO_OVER_FLOW_EN )
N#define SET_UART2_RX_PARITY_ERR_EN       (0x1 << BIT_UART2_RX_PARITY_ERR_EN)
N#define SET_UART2_RX_STOP_ERR_EN         (0x1 << BIT_UART2_RX_STOP_ERR_EN  )
N#define SET_UART2_TX_STOP_END_EN         (0x1 << BIT_UART2_TX_STOP_END_EN  )
N#define SET_UART2_RX_STOP_END_EN         (0x1 << BIT_UART2_RX_STOP_END_EN  )
N#define SET_UART2_RXD_WAKEUP_EN          (0x1 << BIT_UART2_RXD_WAKEUP_EN   )
N
N#define BIT2_TX_FIFO_NEED_WRITE_FLAG     0
N#define BIT2_RX_FIFO_NEED_READ_FLAG      1
N#define BIT2_RX_FIFO_OVER_FLOW_FLAG      2
N#define BIT_UART2_RX_PARITY_ERR_FLAG     3
N#define BIT_UART2_RX_STOP_ERR_FLAG       4
N#define BIT_UART2_TX_STOP_END_FLAG       5
N#define BIT_UART2_RX_STOP_END_FLAG       6
N#define BIT_UART2_RXD_WAKEUP_FLAG        7
N//=====================================================================================
N
N
N
N//IIC
N#define REG_APB4_I2C_CN                 (*((volatile unsigned long *)   0x00806400))
N#define REG_APB4_I2C_STAT               (*((volatile unsigned long *)   0x00806404))
N#define REG_APB4_I2C_DAT                (*((volatile unsigned long *)   0x00806408))
N
N#define I2C_INTR_BIT                    (0x01<<9)
N#define I2C_INTR_TX                     (0x01<<1)
N
N
N//=====================================================================================
N// GPIO
N//=====================================================================================
N#define REG_APB5_GPIOA_CFG              (*((volatile unsigned long *)   0x00806500))
N#define REG_APB5_GPIOA_DATA             (*((volatile unsigned long *)   0x00806504))
N#define REG_APB5_GPIOB_CFG              (*((volatile unsigned long *)   0x00806508))
N#define REG_APB5_GPIOB_DATA             (*((volatile unsigned long *)   0x0080650C))
N#define REG_APB5_GPIOC_CFG              (*((volatile unsigned long *)   0x00806510))
N#define REG_APB5_GPIOC_DATA             (*((volatile unsigned long *)   0x00806514))
N#define REG_APB5_GPIOD_CFG              (*((volatile unsigned long *)   0x00806518))
N#define REG_APB5_GPIOD_DATA             (*((volatile unsigned long *)   0x0080651C))
N#define REG_APB5_GPIOE_CFG              (*((volatile unsigned long *)   0x00806520))
N#define REG_APB5_GPIOE_DATA             (*((volatile unsigned long *)   0x00806524))
N                                                                            
N#define REG_APB5_GPIO_WUATOD_TYPE       (*((volatile unsigned long *)   0x00806540))
N#define REG_APB5_GPIO_WUE_TYPE          (*((volatile unsigned long *)   0x00806544))
N#define REG_APB5_GPIO_WUATOD_ENABLE     (*((volatile unsigned long *)   0x00806548))
N#define REG_APB5_GPIO_WUE_ENABLE        (*((volatile unsigned long *)   0x0080654C))
N#define REG_APB5_GPIO_WUATOD_STAT       (*((volatile unsigned long *)   0x00806550))
N#define REG_APB5_GPIO_WUE_STAT          (*((volatile unsigned long *)   0x00806554))
N
N#define BIT_GPIO_PERI_EN                0
N#define BIT_GPIO_OUT_EN_N               8
N#define BIT_GPIO_PULL_UP                16
N#define BIT_GPIO_PULL_DOWN              24
N#define BIT_GPIO_IN_BUFFER              0
N#define BIT_GPIO_OUT_BUFFER             8
N#define BIT_GPIO_INPUT_EN               16
N
N#define BIT_GPIOA_WU_TYPE               0
N#define BIT_GPIOB_WU_TYPE               8
N#define BIT_GPIOC_WU_TYPE               16
N#define BIT_GPIOD_WU_TYPE               24
N#define BIT_GPIOE_WU_TYPE               0
N
N
N//=====================================================================================
N//RTC
N//=====================================================================================
N#define REG_APB6_RTC_CFG                (*((volatile unsigned long *)   0x00806600))
N#define BIT_RTC_ENABLE                  0
N#define BIT_RTC_CLEAR                   1
N#define BIT_RTC_ALARM_EN                2
N#define BIT_RTC_ALARM_MODE              3
N#define SET_RTC_ENABLE                  (0x1 << BIT_RTC_ENABLE     )
N#define SET_RTC_CLEAR                   (0x1 << BIT_RTC_CLEAR      )
N#define SET_RTC_ALARM_EN                (0x1 << BIT_RTC_ALARM_EN   )
N#define SET_RTC_ALARM_MODE              (0x1 << BIT_RTC_ALARM_MODE )
N
N#define REG_APB6_RTC_UNIT               (*((volatile unsigned long *)   0x00806604))
N#define BIT_RTC_DIV                     0
N#define BIT_RTC_MSUNIT                  2
N#define BIT_RTC_SUNIT                   8
N#define SET_RTC_DIV                     (0x3    << BIT_RTC_DIV   )
N#define SET_RTC_MSUNIT                  (0x3F   << BIT_RTC_MSUNIT)
N#define SET_RTC_SUNIT                   (0xFFFF << BIT_RTC_SUNIT )
N
N#define REG_APB6_RTC_SET                (*((volatile unsigned long *)   0x00806608))
N#define BIT_RTC_SECOND                  0
N#define BIT_RTC_MINUTE                  6
N#define BIT_RTC_HOUR                    12
N#define BIT_RTC_WEEK                    17
N#define SET_RTC_SECOND                  (0x3F << BIT_RTC_SECOND )
N#define SET_RTC_MINUTE                  (0x3F << BIT_RTC_MINUTE )
N#define SET_RTC_HOUR                    (0x1F << BIT_RTC_HOUR   )
N#define SET_RTC_WEEK                    (0x7  << BIT_RTC_WEEK   )
N
N#define REG_APB6_RTC_ALM_TIME           (*((volatile unsigned long *)   0x0080660C))
N#define BIT_RTC_ALARM_SECOND            0
N#define BIT_RTC_ALARM_MINUTE            6
N#define BIT_RTC_ALARM_HOUR              12
N#define BIT_RTC_ALARM_MILLISEC          17
N#define SET_RTC_ALARM_SECOND            (0x3F  << BIT_RTC_ALARM_SECOND   )
N#define SET_RTC_ALARM_MINUTE            (0x3F  << BIT_RTC_ALARM_MINUTE   )
N#define SET_RTC_ALARM_HOUR              (0x1F  << BIT_RTC_ALARM_HOUR     )
N#define SET_RTC_ALARM_MILLISEC          (0x3FF << BIT_RTC_ALARM_MILLISEC )
N
N#define REG_APB6_RTC_ALM_FLAG           (*((volatile unsigned long *)   0x00806610))
N
N// RTC Test Firmware Definition
N#define BK_RTC_CLOCK_MODE         0
N#define BK_RTC_MILLISEC_MODE      1
N//=====================================================================================
N
N
N
N//====================================================================================
N// RND
N//====================================================================================
N#define REG_APB8_RND_CFG                (*((volatile unsigned long *)   0x00806900))
N#define REG_APB8_RND_DAT                (*((volatile unsigned long *)   0x00806904))
N
N
N//=====================================================================================
N// ADC                                   
N//=====================================================================================
N#define REG_APB7_ADC_CFG                (*((volatile unsigned long *)   0x00806700))
N#define REG_APB7_ADC_DAT                (*((volatile unsigned long *)   0x00806704))
N
N#define BIT_ADC_MODE                    0
N#define BIT_ADC_EN                      2
N#define BIT_ADC_CHNL                    3
N#define BIT_ADC_WAIT_CLK_SETTING        7
N#define BIT_ADC_INT_CLEAR               8
N#define BIT_ADC_PRE_DIV                 9
N#define BIT_ADC_DIV1_MODE				15
N#define BIT_ADC_SAMPLE_RATE             16
N#define BIT_ADC_FILTER             		22
N#define BIT_ADC_BUSY             		29
N
N#define BIT_ADC_FIFO_EMPTY              30
N#define BIT_ADC_FIFO_FULL               31
N
N#define SET_ADC_MODE                    (0x3 << BIT_ADC_MODE            )
N#define SET_ADC_EN                      (0x1 << BIT_ADC_EN              )
N#define SET_ADC_CHNL                    (0x7 << BIT_ADC_CHNL            )
N#define SET_ADC_FIFO_EMPTY              (0x1 << BIT_ADC_FIFO_EMPTY      )
N#define SET_ADC_FIFO_FULL               (0x1 << BIT_ADC_FIFO_FULL       )
N#define SET_ADC_SAMPLE_RATE             (0x3 << BIT_ADC_SAMPLE_RATE     )
N#define SET_ADC_WAIT_CLK_SETTING        (0x1 << BIT_ADC_WAIT_CLK_SETTING)
N#define SET_ADC_INT_CLEAR               (0x1 << BIT_ADC_INT_CLEAR       )
N
N//=====================================================================================
N
N
N
N
N//FLASH/RAM space (program)
N#define FLASH_ADDR0                     (*((volatile unsigned long *)   0x0000F000))
N#define FLASH_ADDR1                     (*((volatile unsigned long *)   0x0000F100))
N#define FLASH_ADDR2                     (*((volatile unsigned long *)   0x0000F200))
N#define FLASH_ADDR3                     (*((volatile unsigned long *)   0x0000F300))
N
N
N//===========================================================================================
N//XVR
N
N//===========================================================================================
N// Analog RF module + Transceiver Registers
N//===========================================================================================
N//Analog SPI Registers
N#define APB_XVER_BASE    0x00801400
N#define XVR_REG00               (*((volatile unsigned int *)   (APB_XVER_BASE+0x0)))
N#define XVR_REG01               (*((volatile unsigned int *)   (APB_XVER_BASE+0x4)))
N#define XVR_REG02               (*((volatile unsigned int *)   (APB_XVER_BASE+0x8)))
N#define XVR_REG03               (*((volatile unsigned int *)   (APB_XVER_BASE+0xC)))
N
N#define XVR_REG04               (*((volatile unsigned int *)   (APB_XVER_BASE+0x10)))
N#define XVR_REG05               (*((volatile unsigned int *)   (APB_XVER_BASE+0x14)))
N#define XVR_REG06               (*((volatile unsigned int *)   (APB_XVER_BASE+0x18)))
N#define XVR_REG07               (*((volatile unsigned int *)   (APB_XVER_BASE+0x1C)))
N
N#define XVR_REG08               (*((volatile unsigned int *)   (APB_XVER_BASE+0x20)))
N#define XVR_REG09               (*((volatile unsigned int *)   (APB_XVER_BASE+0x24)))
N#define XVR_REG0A               (*((volatile unsigned int *)   (APB_XVER_BASE+0x28)))
N#define XVR_REG0B               (*((volatile unsigned int *)   (APB_XVER_BASE+0x2C)))
N
N#define XVR_REG0C               (*((volatile unsigned int *)   (APB_XVER_BASE+0x30)))
N#define XVR_REG0D               (*((volatile unsigned int *)   (APB_XVER_BASE+0x34)))
N#define XVR_REG0E               (*((volatile unsigned int *)   (APB_XVER_BASE+0x38)))
N#define XVR_REG0F               (*((volatile unsigned int *)   (APB_XVER_BASE+0x3C)))
N
N// Read-Back Registers
N#define XVR_REG10                (*((volatile unsigned int *)   (APB_XVER_BASE+0x40)))
N#define XVR_REG11                (*((volatile unsigned int *)   (APB_XVER_BASE+0x44)))
N#define XVR_REG12                (*((volatile unsigned int *)   (APB_XVER_BASE+0x48)))
N#define XVR_REG13                (*((volatile unsigned int *)   (APB_XVER_BASE+0x4C)))
N
N#define XVR_REG14                (*((volatile unsigned int *)   (APB_XVER_BASE+0x50)))
N#define XVR_REG15                (*((volatile unsigned int *)   (APB_XVER_BASE+0x54)))
N#define XVR_REG16                (*((volatile unsigned int *)   (APB_XVER_BASE+0x58)))
N#define XVR_REG17                (*((volatile unsigned int *)   (APB_XVER_BASE+0x5C)))
N
N#define XVR_REG18                (*((volatile unsigned int *)   (APB_XVER_BASE+0x60)))
N#define XVR_REG19                (*((volatile unsigned int *)   (APB_XVER_BASE+0x64)))
N#define XVR_REG1A                (*((volatile unsigned int *)   (APB_XVER_BASE+0x68)))
N#define XVR_REG1B                (*((volatile unsigned int *)   (APB_XVER_BASE+0x6C)))
N
N#define XVR_REG1C                (*((volatile unsigned int *)   (APB_XVER_BASE+0x70)))
N#define XVR_REG1D                (*((volatile unsigned int *)   (APB_XVER_BASE+0x74)))
N#define XVR_REG1E                (*((volatile unsigned int *)   (APB_XVER_BASE+0x78)))
N#define XVR_REG1F                (*((volatile unsigned int *)   (APB_XVER_BASE+0x7C)))
N
N// XVR Config Registers 
N#define XVR_REG20                      (*((volatile unsigned int *)   (APB_XVER_BASE+0x80)))
N#define XVR_REG21                      (*((volatile unsigned int *)   (APB_XVER_BASE+0x84)))
N#define XVR_REG22                      (*((volatile unsigned int *)   (APB_XVER_BASE+0x88)))
N#define XVR_REG23                      (*((volatile unsigned int *)   (APB_XVER_BASE+0x8C)))
N
N#define XVR_REG24                      (*((volatile unsigned int *)   (APB_XVER_BASE+0x90)))
N#define XVR_REG25                      (*((volatile unsigned int *)   (APB_XVER_BASE+0x94)))
N#define XVR_REG26                      (*((volatile unsigned int *)   (APB_XVER_BASE+0x98)))
N#define XVR_REG27                      (*((volatile unsigned int *)   (APB_XVER_BASE+0x9C)))
N
N#define XVR_REG28                      (*((volatile unsigned int *)   (APB_XVER_BASE+0xA0)))
N#define XVR_REG29                      (*((volatile unsigned int *)   (APB_XVER_BASE+0xA4)))
N#define XVR_REG2A                      (*((volatile unsigned int *)   (APB_XVER_BASE+0xA8)))
N#define XVR_REG2B                      (*((volatile unsigned int *)   (APB_XVER_BASE+0xAC)))
N
N#define XVR_REG2C                      (*((volatile unsigned int *)   (APB_XVER_BASE+0xB0)))
N#define XVR_REG2D                      (*((volatile unsigned int *)   (APB_XVER_BASE+0xB4)))
N#define XVR_REG2E                      (*((volatile unsigned int *)   (APB_XVER_BASE+0xB8)))
N#define XVR_REG2F                      (*((volatile unsigned int *)   (APB_XVER_BASE+0xBC)))
N
N#define XVR_REG30                      (*((volatile unsigned int *)   (APB_XVER_BASE+0xC0)))
N#define XVR_REG31                      (*((volatile unsigned int *)   (APB_XVER_BASE+0xC4)))
N#define XVR_REG32                      (*((volatile unsigned int *)   (APB_XVER_BASE+0xC8)))
N#define XVR_REG33                      (*((volatile unsigned int *)   (APB_XVER_BASE+0xCC)))
N
N#define XVR_REG34                      (*((volatile unsigned int *)   (APB_XVER_BASE+0xD0)))
N#define XVR_REG35                      (*((volatile unsigned int *)   (APB_XVER_BASE+0xD4)))
N#define XVR_REG36                      (*((volatile unsigned int *)   (APB_XVER_BASE+0xD8)))
N#define XVR_REG37                      (*((volatile unsigned int *)   (APB_XVER_BASE+0xDC)))
N
N#define XVR_REG38                      (*((volatile unsigned int *)   (APB_XVER_BASE+0xE0)))
N#define XVR_REG39                      (*((volatile unsigned int *)   (APB_XVER_BASE+0xE4)))
N#define XVR_REG3A                      (*((volatile unsigned int *)   (APB_XVER_BASE+0xE8)))
N#define XVR_REG3B                      (*((volatile unsigned int *)   (APB_XVER_BASE+0xEC)))
N
N#define XVR_REG3C                      (*((volatile unsigned int *)   (APB_XVER_BASE+0xF0)))
N#define XVR_REG3D                      (*((volatile unsigned int *)   (APB_XVER_BASE+0xF4)))
N#define XVR_REG3E                      (*((volatile unsigned int *)   (APB_XVER_BASE+0xF8)))
N#define XVR_REG3F                      (*((volatile unsigned int *)   (APB_XVER_BASE+0xFC)))
N
N#define XVR_REG40                      (*((volatile unsigned int *)   (APB_XVER_BASE+0x100)))
N#define XVR_REG41                      (*((volatile unsigned int *)   (APB_XVER_BASE+0x104)))
N#define XVR_REG42                      (*((volatile unsigned int *)   (APB_XVER_BASE+0x108)))
N#define XVR_REG43                      (*((volatile unsigned int *)   (APB_XVER_BASE+0x10C)))
N
N#define XVR_REG44                      (*((volatile unsigned int *)   (APB_XVER_BASE+0x110)))
N#define XVR_REG45                      (*((volatile unsigned int *)   (APB_XVER_BASE+0x114)))
N#define XVR_REG46                      (*((volatile unsigned int *)   (APB_XVER_BASE+0x118)))
N#define XVR_REG47                      (*((volatile unsigned int *)   (APB_XVER_BASE+0x11C)))
N
N#define XVR_REG48                      (*((volatile unsigned int *)   (APB_XVER_BASE+0x120)))
N#define XVR_REG49                      (*((volatile unsigned int *)   (APB_XVER_BASE+0x124)))
N#define XVR_REG4A                      (*((volatile unsigned int *)   (APB_XVER_BASE+0x128)))
N#define XVR_REG4B                      (*((volatile unsigned int *)   (APB_XVER_BASE+0x12C)))
N
N#define XVR_REG4C                      (*((volatile unsigned int *)   (APB_XVER_BASE+0x130)))
N#define XVR_REG4D                      (*((volatile unsigned int *)   (APB_XVER_BASE+0x134)))
N#define XVR_REG4E                      (*((volatile unsigned int *)   (APB_XVER_BASE+0x138)))
N#define XVR_REG4F                      (*((volatile unsigned int *)   (APB_XVER_BASE+0x13C)))
N
N
N/// backup analog register
N//extern u_int32 backup_xvr_analog_reg[];
N#define mHWreg_Assign_XVR_Regsiter(No,Value) \
N    { \
N        XVR_REG##No = Value; \
N    }
X#define mHWreg_Assign_XVR_Regsiter(No,Value)     {         XVR_REG##No = Value;     }
N		
N
N#define REG_AHB1_XVER_BASE              (*((volatile unsigned long *)   0x00801488))
N
N#define BIT_AUTO_SYNCWORD               (0x1<<31)
N#define BIT_AUTO_SYNCWIN                (0x1<<30)
N#define BIT_AUTO_CHNN                   (0x1<<29)
N
N
N//RW////////////////////////////////////////////////////////////////////////////////
N#define REG_AHB10_RW_INT_MASK        (*((volatile unsigned long *)   0x0081000C))
N#define REG_AHB10_RW_INT_FLAG          (*((volatile unsigned long *)   0x00810010))
N#define REG_AHB10_RW_INT_FLAG_RAW          (*((volatile unsigned long *)   0x00810014))	
N#define REG_AHB10_RW_INT_ACK        (*((volatile unsigned long *)   0x00810018))
N#define REG_AHB10_RW_BASETIMECNT    (*((volatile unsigned long *)   0x0081001C))
N#define REG_AHB10_RW_DEEPSLCNTL     (*((volatile unsigned long *)   0x00810030))
N#define REG_AHB10_RW_DEEPSLTIME     (*((volatile unsigned long *)   0x00810034))
N#define REG_AHB10_RW_DEEPSLDUR     (*((volatile unsigned long *)   0x00810038))
N#define REG_AHB10_RW_ENBPRESET     (*((volatile unsigned long *)   0x0081003C))
N#define REG_AHB10_RW_FINECNTCORR     (*((volatile unsigned long *)   0x00810040))
N#define REG_AHB10_RW_BASETIMECNTCORR  (*((volatile unsigned long *)   0x00810044))
N#define REG_AHB10_RW_ERRORTYPESTAT    (*((volatile unsigned long *)   0x00810060))
N
N
N#define INT_RW_AUDIOINT2STAT_MASK      (0x01<<12)
N#define INT_RW_AUDIOINT1STAT_MASK      (0x01<<11)
N#define INT_RW_AUDIOINT0STAT_MASK      (0x01<< 10)
N#define INT_RW_SWINTSTAT_MASK          (0x01<< 9)
N#define INT_RW_EVENTAPFAINTSTAT_MASK      (0x01<< 8)
N#define INT_RW_FINETGTIMINTSTAT_MASK      (0x01<< 7)
N#define INT_RW_GROSSTGTIMINTSTAT_MASK     (0x01<< 6)
N#define INT_RW_ERRORINTSTAT_MASK     (0x01<< 5)
N#define INT_RW_CRYPTINTSTAT_MASK     (0x01<< 4)
N#define INT_RW_EVENTINTSTAT_MASK     (0x01<< 3)
N#define INT_RW_SLPINTSTAT_MASK       (0x01<< 2)
N#define INT_RW_RXINTSTAT_MASK        (0x01<< 1)
N#define INT_RW_CSCNTINTSTAT_MASK     (0x01<< 0)
N#define INT_RW_AUDIOINT2STAT_bit      (0x01<<12)
N#define INT_RW_AUDIOINT1STAT_bit      (0x01<<11)
N#define INT_RW_AUDIOINT0STAT_bit      (0x01<< 10)
N#define INT_RW_SWINTSTAT_bit          (0x01<< 9)
N#define INT_RW_EVENTAPFAINTSTAT_bit      (0x01<< 8)
N#define INT_RW_FINETGTIMINTSTAT_bit      (0x01<< 7)
N#define INT_RW_GROSSTGTIMINTSTAT_bit     (0x01<< 6)
N#define INT_RW_ERRORINTSTAT_bit     (0x01<< 5)
N#define INT_RW_CRYPTINTSTAT_bit     (0x01<< 4)
N#define INT_RW_EVENTINTSTAT_bit     (0x01<< 3)
N#define INT_RW_SLPINTSTAT_bit       (0x01<< 2)
N#define INT_RW_RXINTSTAT_bit        (0x01<< 1)
N#define INT_RW_CSCNTINTSTAT_bit     (0x01<< 0)
N
N#define RW_ENBPRESET_TWEXT_bit     21
N#define RW_ENBPRESET_TWOSC_bit     10
N#define RW_ENBPRESET_TWRW_bit     0
N
N#endif
N
L 5 "app\bim_uart.c" 2
N#include <stdlib.h>    // standard lib functions
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\stdlib.h" 1
N/* stdlib.h: ANSI draft (X3J11 May 88) library header, section 4.10 */
N/* Copyright (C) Codemist Ltd., 1988-1993.                          */
N/* Copyright 1991-1998,2014 ARM Limited. All rights reserved.       */
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: agrant $
N */
N 
N/*
N * stdlib.h declares four types, several general purpose functions,
N * and defines several macros.
N */
N
N#ifndef __stdlib_h
N#define __stdlib_h
N#define __ARMCLIB_VERSION 5060044
N
N#if defined(__clang__) || (defined(__ARMCC_VERSION) && !defined(__STRICT_ANSI__))
X#if 0L || (1L && !0L)
N  /* armclang and non-strict armcc allow 'long long' in system headers */
N  #define __LONGLONG long long
N#else
S  /* strict armcc has '__int64' */
S  #define __LONGLONG __int64
N#endif
N
N#define _ARMABI __declspec(__nothrow)
N#define _ARMABI_PURE __declspec(__nothrow) __attribute__((const))
N#define _ARMABI_NORETURN __declspec(__nothrow) __declspec(__noreturn)
N#define _ARMABI_THROW
N
N  #ifndef __STDLIB_DECLS
N  #define __STDLIB_DECLS
N
N  /*
N   * Some of these declarations are new in C99.  To access them in C++
N   * you can use -D__USE_C99_STDLIB (or -D__USE_C99ALL).
N   */
N  #ifndef __USE_C99_STDLIB
N    #if defined(__USE_C99_ALL) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X    #if 0L || (1L && 199901L <= 199901L) || (0L && 201103L <= __cplusplus)
N      #define __USE_C99_STDLIB 1
N    #endif
N  #endif
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS ::std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 0L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N#elif !defined(__size_t)
S  #define __size_t 1
S  #if __sizeof_ptr == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
S  #else
S    typedef unsigned int size_t;   /* see <stddef.h> */
S  #endif
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
N#ifndef __cplusplus  /* wchar_t is a builtin type for C++ */
N  #if !defined(__STRICT_ANSI__)
X  #if !0L
N   /* unconditional in non-strict C for consistency of debug info */
N   #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
X   #if 0L || (0L && __ARM_SIZEOF_WCHAR_T == 4)
S    typedef unsigned int wchar_t; /* see <stddef.h> */
N   #else
N    typedef unsigned short wchar_t; /* see <stddef.h> */
N   #endif
N  #elif !defined(__wchar_t)
S    #define __wchar_t 1
S   #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
S    typedef unsigned int wchar_t; /* see <stddef.h> */
S   #else
S    typedef unsigned short wchar_t; /* see <stddef.h> */
S   #endif
N  #endif
N#endif
N
Ntypedef struct div_t { int quot, rem; } div_t;
N   /* type of the value returned by the div function. */
Ntypedef struct ldiv_t { long int quot, rem; } ldiv_t;
N   /* type of the value returned by the ldiv function. */
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || 1
Ntypedef struct lldiv_t { __LONGLONG quot, rem; } lldiv_t;
Xtypedef struct lldiv_t { long long quot, rem; } lldiv_t;
N   /* type of the value returned by the lldiv function. */
N#endif
N
N#ifdef __EXIT_FAILURE
S#  define EXIT_FAILURE __EXIT_FAILURE
S   /*
S    * an integral expression which may be used as an argument to the exit
S    * function to return unsuccessful termination status to the host
S    * environment.
S    */
N#else
N#  define EXIT_FAILURE 1  /* unixoid */
N#endif
N#define EXIT_SUCCESS 0
N   /*
N    * an integral expression which may be used as an argument to the exit
N    * function to return successful termination status to the host
N    * environment.
N    */
N
N   /*
N    * Defining __USE_ANSI_EXAMPLE_RAND at compile time switches to
N    * the example implementation of rand() and srand() provided in
N    * the ANSI C standard. This implementation is very poor, but is
N    * provided for completeness.
N    */
N#ifdef __USE_ANSI_EXAMPLE_RAND
S#define srand _ANSI_srand
S#define rand _ANSI_rand
S#define RAND_MAX 0x7fff
N#else
N#define RAND_MAX 0x7fffffff
N#endif
N   /*
N    * RAND_MAX: an integral constant expression, the value of which
N    * is the maximum value returned by the rand function.
N    */
Nextern _ARMABI int __aeabi_MB_CUR_MAX(void);
Xextern __declspec(__nothrow) int __aeabi_MB_CUR_MAX(void);
N#define MB_CUR_MAX ( __aeabi_MB_CUR_MAX() )
N   /*
N    * a positive integer expression whose value is the maximum number of bytes
N    * in a multibyte character for the extended character set specified by the
N    * current locale (category LC_CTYPE), and whose value is never greater
N    * than MB_LEN_MAX.
N    */
N
N   /*
N    * If the compiler supports signalling nans as per N965 then it
N    * will define __SUPPORT_SNAN__, in which case a user may define
N    * _WANT_SNAN in order to obtain a compliant version of the strtod
N    * family of functions.
N    */
N#if defined(__SUPPORT_SNAN__) && defined(_WANT_SNAN)
X#if 0L && 0L
S#pragma import(__use_snan)
N#endif
N
Nextern _ARMABI double atof(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) double atof(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to double
N    * representation.
N    * Returns: the converted value.
N    */
Nextern _ARMABI int atoi(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int atoi(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to int
N    * representation.
N    * Returns: the converted value.
N    */
Nextern _ARMABI long int atol(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long int atol(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to long int
N    * representation.
N    * Returns: the converted value.
N    */
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || 1
Nextern _ARMABI __LONGLONG atoll(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long long atoll(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to
N    * long long int representation.
N    * Returns: the converted value.
N    */
N#endif
N
Nextern _ARMABI double strtod(const char * __restrict /*nptr*/, char ** __restrict /*endptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) double strtod(const char * __restrict  , char ** __restrict  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to double
N    * representation. First it decomposes the input string into three parts:
N    * an initial, possibly empty, sequence of white-space characters (as
N    * specified by the isspace function), a subject sequence resembling a
N    * floating point constant; and a final string of one or more unrecognised
N    * characters, including the terminating null character of the input string.
N    * Then it attempts to convert the subject sequence to a floating point
N    * number, and returns the result. A pointer to the final string is stored
N    * in the object pointed to by endptr, provided that endptr is not a null
N    * pointer.
N    * Returns: the converted value if any. If no conversion could be performed,
N    *          zero is returned. If the correct value is outside the range of
N    *          representable values, plus or minus HUGE_VAL is returned
N    *          (according to the sign of the value), and the value of the macro
N    *          ERANGE is stored in errno. If the correct value would cause
N    *          underflow, zero is returned and the value of the macro ERANGE is
N    *          stored in errno.
N    */
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || 1
Nextern _ARMABI float strtof(const char * __restrict /*nptr*/, char ** __restrict /*endptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) float strtof(const char * __restrict  , char ** __restrict  ) __attribute__((__nonnull__(1)));
Nextern _ARMABI long double strtold(const char * __restrict /*nptr*/, char ** __restrict /*endptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long double strtold(const char * __restrict  , char ** __restrict  ) __attribute__((__nonnull__(1)));
N   /*
N    * same as strtod, but return float and long double respectively.
N    */
N#endif
Nextern _ARMABI long int strtol(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) long int strtol(const char * __restrict  ,
N                        char ** __restrict /*endptr*/, int /*base*/) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to long int
N    * representation. First it decomposes the input string into three parts:
N    * an initial, possibly empty, sequence of white-space characters (as
N    * specified by the isspace function), a subject sequence resembling an
N    * integer represented in some radix determined by the value of base, and a
N    * final string of one or more unrecognised characters, including the
N    * terminating null character of the input string. Then it attempts to
N    * convert the subject sequence to an integer, and returns the result.
N    * If the value of base is 0, the expected form of the subject sequence is
N    * that of an integer constant (described in ANSI Draft, section 3.1.3.2),
N    * optionally preceded by a '+' or '-' sign, but not including an integer
N    * suffix. If the value of base is between 2 and 36, the expected form of
N    * the subject sequence is a sequence of letters and digits representing an
N    * integer with the radix specified by base, optionally preceded by a plus
N    * or minus sign, but not including an integer suffix. The letters from a
N    * (or A) through z (or Z) are ascribed the values 10 to 35; only letters
N    * whose ascribed values are less than that of the base are permitted. If
N    * the value of base is 16, the characters 0x or 0X may optionally precede
N    * the sequence of letters and digits following the sign if present.
N    * A pointer to the final string is stored in the object
N    * pointed to by endptr, provided that endptr is not a null pointer.
N    * Returns: the converted value if any. If no conversion could be performed,
N    *          zero is returned and nptr is stored in *endptr.
N    *          If the correct value is outside the range of
N    *          representable values, LONG_MAX or LONG_MIN is returned
N    *          (according to the sign of the value), and the value of the
N    *          macro ERANGE is stored in errno.
N    */
Nextern _ARMABI unsigned long int strtoul(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) unsigned long int strtoul(const char * __restrict  ,
N                                       char ** __restrict /*endptr*/, int /*base*/) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to unsigned
N    * long int representation. First it decomposes the input string into three
N    * parts: an initial, possibly empty, sequence of white-space characters (as
N    * determined by the isspace function), a subject sequence resembling an
N    * unsigned integer represented in some radix determined by the value of
N    * base, and a final string of one or more unrecognised characters,
N    * including the terminating null character of the input string. Then it
N    * attempts to convert the subject sequence to an unsigned integer, and
N    * returns the result. If the value of base is zero, the expected form of
N    * the subject sequence is that of an integer constant (described in ANSI
N    * Draft, section 3.1.3.2), optionally preceded by a '+' or '-' sign, but
N    * not including an integer suffix. If the value of base is between 2 and
N    * 36, the expected form of the subject sequence is a sequence of letters
N    * and digits representing an integer with the radix specified by base,
N    * optionally preceded by a '+' or '-' sign, but not including an integer
N    * suffix. The letters from a (or A) through z (or Z) stand for the values
N    * 10 to 35; only letters whose ascribed values are less than that of the
N    * base are permitted. If the value of base is 16, the characters 0x or 0X
N    * may optionally precede the sequence of letters and digits following the
N    * sign, if present. A pointer to the final string is stored in the object
N    * pointed to by endptr, provided that endptr is not a null pointer.
N    * Returns: the converted value if any. If no conversion could be performed,
N    *          zero is returned and nptr is stored in *endptr.
N    *          If the correct value is outside the range of
N    *          representable values, ULONG_MAX is returned, and the value of
N    *          the macro ERANGE is stored in errno.
N    */
N
N/* C90 reserves all names beginning with 'str' */
Nextern _ARMABI __LONGLONG strtoll(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) long long strtoll(const char * __restrict  ,
N                                  char ** __restrict /*endptr*/, int /*base*/)
N                          __attribute__((__nonnull__(1)));
N   /*
N    * as strtol but returns a long long int value.  If the correct value is
N    * outside the range of representable values,  LLONG_MAX or LLONG_MIN is
N    * returned (according to the sign of the value), and the value of the
N    * macro ERANGE is stored in errno.
N    */
Nextern _ARMABI unsigned __LONGLONG strtoull(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) unsigned long long strtoull(const char * __restrict  ,
N                                            char ** __restrict /*endptr*/, int /*base*/)
N                                   __attribute__((__nonnull__(1)));
N   /*
N    * as strtoul but returns an unsigned long long int value.  If the correct
N    * value is outside the range of representable values, ULLONG_MAX is returned,
N    * and the value of the macro ERANGE is stored in errno.
N    */
N
Nextern _ARMABI int rand(void);
Xextern __declspec(__nothrow) int rand(void);
N   /*
N    * Computes a sequence of pseudo-random integers in the range 0 to RAND_MAX.
N    * Uses an additive generator (Mitchell & Moore) of the form:
N    *   Xn = (X[n-24] + X[n-55]) MOD 2^31
N    * This is described in section 3.2.2 of Knuth, vol 2. It's period is
N    * in excess of 2^55 and its randomness properties, though unproven, are
N    * conjectured to be good. Empirical testing since 1958 has shown no flaws.
N    * Returns: a pseudo-random integer.
N    */
Nextern _ARMABI void srand(unsigned int /*seed*/);
Xextern __declspec(__nothrow) void srand(unsigned int  );
N   /*
N    * uses its argument as a seed for a new sequence of pseudo-random numbers
N    * to be returned by subsequent calls to rand. If srand is then called with
N    * the same seed value, the sequence of pseudo-random numbers is repeated.
N    * If rand is called before any calls to srand have been made, the same
N    * sequence is generated as when srand is first called with a seed value
N    * of 1.
N    */
N
Nstruct _rand_state { int __x[57]; };
Nextern _ARMABI int _rand_r(struct _rand_state *);
Xextern __declspec(__nothrow) int _rand_r(struct _rand_state *);
Nextern _ARMABI void _srand_r(struct _rand_state *, unsigned int);
Xextern __declspec(__nothrow) void _srand_r(struct _rand_state *, unsigned int);
Nstruct _ANSI_rand_state { int __x[1]; };
Nextern _ARMABI int _ANSI_rand_r(struct _ANSI_rand_state *);
Xextern __declspec(__nothrow) int _ANSI_rand_r(struct _ANSI_rand_state *);
Nextern _ARMABI void _ANSI_srand_r(struct _ANSI_rand_state *, unsigned int);
Xextern __declspec(__nothrow) void _ANSI_srand_r(struct _ANSI_rand_state *, unsigned int);
N   /*
N    * Re-entrant variants of both flavours of rand, which operate on
N    * an explicitly supplied state buffer.
N    */
N
Nextern _ARMABI void *calloc(size_t /*nmemb*/, size_t /*size*/);
Xextern __declspec(__nothrow) void *calloc(size_t  , size_t  );
N   /*
N    * allocates space for an array of nmemb objects, each of whose size is
N    * 'size'. The space is initialised to all bits zero.
N    * Returns: either a null pointer or a pointer to the allocated space.
N    */
Nextern _ARMABI void free(void * /*ptr*/);
Xextern __declspec(__nothrow) void free(void *  );
N   /*
N    * causes the space pointed to by ptr to be deallocated (i.e., made
N    * available for further allocation). If ptr is a null pointer, no action
N    * occurs. Otherwise, if ptr does not match a pointer earlier returned by
N    * calloc, malloc or realloc or if the space has been deallocated by a call
N    * to free or realloc, the behaviour is undefined.
N    */
Nextern _ARMABI void *malloc(size_t /*size*/);
Xextern __declspec(__nothrow) void *malloc(size_t  );
N   /*
N    * allocates space for an object whose size is specified by 'size' and whose
N    * value is indeterminate.
N    * Returns: either a null pointer or a pointer to the allocated space.
N    */
Nextern _ARMABI void *realloc(void * /*ptr*/, size_t /*size*/);
Xextern __declspec(__nothrow) void *realloc(void *  , size_t  );
N   /*
N    * changes the size of the object pointed to by ptr to the size specified by
N    * size. The contents of the object shall be unchanged up to the lesser of
N    * the new and old sizes. If the new size is larger, the value of the newly
N    * allocated portion of the object is indeterminate. If ptr is a null
N    * pointer, the realloc function behaves like a call to malloc for the
N    * specified size. Otherwise, if ptr does not match a pointer earlier
N    * returned by calloc, malloc or realloc, or if the space has been
N    * deallocated by a call to free or realloc, the behaviour is undefined.
N    * If the space cannot be allocated, the object pointed to by ptr is
N    * unchanged. If size is zero and ptr is not a null pointer, the object it
N    * points to is freed.
N    * Returns: either a null pointer or a pointer to the possibly moved
N    *          allocated space.
N    */
N#if !defined(__STRICT_ANSI__)
X#if !0L
Nextern _ARMABI int posix_memalign(void ** /*ret*/, size_t /*alignment*/, size_t /*size*/);
Xextern __declspec(__nothrow) int posix_memalign(void **  , size_t  , size_t  );
N   /*
N    * allocates space for an object of size 'size', aligned to a
N    * multiple of 'alignment' (which must be a power of two and at
N    * least 4).
N    *
N    * On success, a pointer to the allocated object is stored in
N    * *ret, and zero is returned. On failure, the return value is
N    * either ENOMEM (allocation failed because no suitable piece of
N    * memory was available) or EINVAL (the 'alignment' parameter was
N    * invalid).
N    */
N#endif
Ntypedef int (*__heapprt)(void *, char const *, ...);
Nextern _ARMABI void __heapstats(int (* /*dprint*/)(void * /*param*/,
Xextern __declspec(__nothrow) void __heapstats(int (*  )(void *  ,
N                                           char const * /*format*/, ...),
N                        void * /*param*/) __attribute__((__nonnull__(1)));
N   /*
N    * reports current heap statistics (eg. number of free blocks in
N    * the free-list). Output is as implementation-defined free-form
N    * text, provided via the dprint function. `param' gives an
N    * extra data word to pass to dprint. You can call
N    * __heapstats(fprintf,stdout) by casting fprintf to the above
N    * function type; the typedef `__heapprt' is provided for this
N    * purpose.
N    *
N    * `dprint' will not be called while the heap is being examined,
N    * so it can allocate memory itself without trouble.
N    */
Nextern _ARMABI int __heapvalid(int (* /*dprint*/)(void * /*param*/,
Xextern __declspec(__nothrow) int __heapvalid(int (*  )(void *  ,
N                                           char const * /*format*/, ...),
N                       void * /*param*/, int /*verbose*/) __attribute__((__nonnull__(1)));
N   /*
N    * performs a consistency check on the heap. Errors are reported
N    * through dprint, like __heapstats. If `verbose' is nonzero,
N    * full diagnostic information on the heap state is printed out.
N    *
N    * This routine probably won't work if the heap isn't a
N    * contiguous chunk (for example, if __user_heap_extend has been
N    * overridden).
N    *
N    * `dprint' may be called while the heap is being examined or
N    * even in an invalid state, so it must perform no memory
N    * allocation. In particular, if `dprint' calls (or is) a stdio
N    * function, the stream it outputs to must already have either
N    * been written to or been setvbuf'ed, or else the system will
N    * allocate buffer space for it on the first call to dprint.
N    */
Nextern _ARMABI_NORETURN void abort(void);
Xextern __declspec(__nothrow) __declspec(__noreturn) void abort(void);
N   /*
N    * causes abnormal program termination to occur, unless the signal SIGABRT
N    * is being caught and the signal handler does not return. Whether open
N    * output streams are flushed or open streams are closed or temporary
N    * files removed is implementation-defined.
N    * An implementation-defined form of the status 'unsuccessful termination'
N    * is returned to the host environment by means of a call to
N    * raise(SIGABRT).
N    */
N
Nextern _ARMABI int atexit(void (* /*func*/)(void)) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int atexit(void (*  )(void)) __attribute__((__nonnull__(1)));
N   /*
N    * registers the function pointed to by func, to be called without its
N    * arguments at normal program termination. It is possible to register at
N    * least 32 functions.
N    * Returns: zero if the registration succeeds, nonzero if it fails.
N    */
N#if defined(__EDG__) && !defined(__GNUC__)
X#if 1L && !0L
N#define __LANGUAGE_LINKAGE_CHANGES_FUNCTION_TYPE
N#endif
N#if defined(__cplusplus) && defined(__LANGUAGE_LINKAGE_CHANGES_FUNCTION_TYPE) 
X#if 0L && 1L 
S    /* atexit that takes a ptr to a function with C++ linkage 
S     * but not in GNU mode  
S     */
S    typedef void (* __C_exitfuncptr)();
S    extern "C++"
S    inline int atexit(void (* __func)()) {
S      return atexit((__C_exitfuncptr)__func);
S    }
N#endif
N
N
Nextern _ARMABI_NORETURN void exit(int /*status*/);
Xextern __declspec(__nothrow) __declspec(__noreturn) void exit(int  );
N   /*
N    * causes normal program termination to occur. If more than one call to the
N    * exit function is executed by a program, the behaviour is undefined.
N    * First, all functions registered by the atexit function are called, in the
N    * reverse order of their registration.
N    * Next, all open output streams are flushed, all open streams are closed,
N    * and all files created by the tmpfile function are removed.
N    * Finally, control is returned to the host environment. If the value of
N    * status is zero or EXIT_SUCCESS, an implementation-defined form of the
N    * status 'successful termination' is returned. If the value of status is
N    * EXIT_FAILURE, an implementation-defined form of the status
N    * 'unsuccessful termination' is returned. Otherwise the status returned
N    * is implementation-defined.
N    */
N
Nextern _ARMABI_NORETURN void _Exit(int /*status*/);
Xextern __declspec(__nothrow) __declspec(__noreturn) void _Exit(int  );
N   /*
N    * causes normal program termination to occur. No functions registered
N    * by the atexit function are called.
N    * In this implementation, all open output streams are flushed, all
N    * open streams are closed, and all files created by the tmpfile function
N    * are removed.
N    * Control is returned to the host environment. The status returned to
N    * the host environment is determined in the same way as for 'exit'.
N    */     
N
Nextern _ARMABI char *getenv(const char * /*name*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *getenv(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * searches the environment list, provided by the host environment, for a
N    * string that matches the string pointed to by name. The set of environment
N    * names and the method for altering the environment list are
N    * implementation-defined.
N    * Returns: a pointer to a string associated with the matched list member.
N    *          The array pointed to shall not be modified by the program, but
N    *          may be overwritten by a subsequent call to the getenv function.
N    *          If the specified name cannot be found, a null pointer is
N    *          returned.
N    */
N
Nextern _ARMABI int  system(const char * /*string*/);
Xextern __declspec(__nothrow) int  system(const char *  );
N   /*
N    * passes the string pointed to by string to the host environment to be
N    * executed by a command processor in an implementation-defined manner.
N    * A null pointer may be used for string, to inquire whether a command
N    * processor exists.
N    *
N    * Returns: If the argument is a null pointer, the system function returns
N    *          non-zero only if a command processor is available. If the
N    *          argument is not a null pointer, the system function returns an
N    *          implementation-defined value.
N    */
N
Nextern _ARMABI_THROW void *bsearch(const void * /*key*/, const void * /*base*/,
Xextern  void *bsearch(const void *  , const void *  ,
N              size_t /*nmemb*/, size_t /*size*/,
N              int (* /*compar*/)(const void *, const void *)) __attribute__((__nonnull__(1,2,5)));
N   /*
N    * searches an array of nmemb objects, the initial member of which is
N    * pointed to by base, for a member that matches the object pointed to by
N    * key. The size of each member of the array is specified by size.
N    * The contents of the array shall be in ascending sorted order according to
N    * a comparison function pointed to by compar, which is called with two
N    * arguments that point to the key object and to an array member, in that
N    * order. The function shall return an integer less than, equal to, or
N    * greater than zero if the key object is considered, respectively, to be
N    * less than, to match, or to be greater than the array member.
N    * Returns: a pointer to a matching member of the array, or a null pointer
N    *          if no match is found. If two members compare as equal, which
N    *          member is matched is unspecified.
N    */
N#if defined(__cplusplus) && defined(__LANGUAGE_LINKAGE_CHANGES_FUNCTION_TYPE)
X#if 0L && 1L
S    /* bsearch that takes a ptr to a function with C++ linkage 
S     * but not in GNU mode
S     */
S    typedef int (* __C_compareprocptr)(const void *, const void *);
S    extern "C++"
S    void *bsearch(const void * __key, const void * __base,
S              size_t __nmemb, size_t __size,
S              int (* __compar)(const void *, const void *)) __attribute__((__nonnull__(1,2,5)));
S    extern "C++"
S    inline void *bsearch(const void * __key, const void * __base,
S              size_t __nmemb, size_t __size,
S              int (* __compar)(const void *, const void *)) {
S      return bsearch(__key, __base, __nmemb, __size, (__C_compareprocptr)__compar);
S    }
N#endif
N
N
Nextern _ARMABI_THROW void qsort(void * /*base*/, size_t /*nmemb*/, size_t /*size*/,
Xextern  void qsort(void *  , size_t  , size_t  ,
N           int (* /*compar*/)(const void *, const void *)) __attribute__((__nonnull__(1,4)));
N   /*
N    * sorts an array of nmemb objects, the initial member of which is pointed
N    * to by base. The size of each object is specified by size.
N    * The contents of the array shall be in ascending order according to a
N    * comparison function pointed to by compar, which is called with two
N    * arguments that point to the objects being compared. The function shall
N    * return an integer less than, equal to, or greater than zero if the first
N    * argument is considered to be respectively less than, equal to, or greater
N    * than the second. If two members compare as equal, their order in the
N    * sorted array is unspecified.
N    */
N
N#if defined(__cplusplus) && defined(__LANGUAGE_LINKAGE_CHANGES_FUNCTION_TYPE)
X#if 0L && 1L
S    /* qsort that takes a ptr to a function with C++ linkage 
S     * but not in GNU mode
S     */    
S    extern "C++"
S    void qsort(void * __base, size_t __nmemb, size_t __size,
S               int (* __compar)(const void *, const void *)) __attribute__((__nonnull__(1,4)));
S    extern "C++"
S    inline void qsort(void * __base, size_t __nmemb, size_t __size,
S                      int (* __compar)(const void *, const void *)) {
S      qsort(__base, __nmemb, __size, (__C_compareprocptr)__compar);
S    }
N#endif
N
Nextern _ARMABI_PURE int abs(int /*j*/);
Xextern __declspec(__nothrow) __attribute__((const)) int abs(int  );
N   /*
N    * computes the absolute value of an integer j. If the result cannot be
N    * represented, the behaviour is undefined.
N    * Returns: the absolute value.
N    */
N
Nextern _ARMABI_PURE div_t div(int /*numer*/, int /*denom*/);
Xextern __declspec(__nothrow) __attribute__((const)) div_t div(int  , int  );
N   /*
N    * computes the quotient and remainder of the division of the numerator
N    * numer by the denominator denom. If the division is inexact, the resulting
N    * quotient is the integer of lesser magnitude that is the nearest to the
N    * algebraic quotient. If the result cannot be represented, the behaviour is
N    * undefined; otherwise, quot * denom + rem shall equal numer.
N    * Returns: a structure of type div_t, comprising both the quotient and the
N    *          remainder. the structure shall contain the following members,
N    *          in either order.
N    *          int quot; int rem;
N    */
Nextern _ARMABI_PURE long int labs(long int /*j*/);
Xextern __declspec(__nothrow) __attribute__((const)) long int labs(long int  );
N   /*
N    * computes the absolute value of an long integer j. If the result cannot be
N    * represented, the behaviour is undefined.
N    * Returns: the absolute value.
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE long abs(long int x) { return labs(x); }
N#endif
N
Nextern _ARMABI_PURE ldiv_t ldiv(long int /*numer*/, long int /*denom*/);
Xextern __declspec(__nothrow) __attribute__((const)) ldiv_t ldiv(long int  , long int  );
N   /*
N    * computes the quotient and remainder of the division of the numerator
N    * numer by the denominator denom. If the division is inexact, the sign of
N    * the resulting quotient is that of the algebraic quotient, and the
N    * magnitude of the resulting quotient is the largest integer less than the
N    * magnitude of the algebraic quotient. If the result cannot be represented,
N    * the behaviour is undefined; otherwise, quot * denom + rem shall equal
N    * numer.
N    * Returns: a structure of type ldiv_t, comprising both the quotient and the
N    *          remainder. the structure shall contain the following members,
N    *          in either order.
N    *          long int quot; long int rem;
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE ldiv_t div(long int __numer, long int __denom) {
S       return ldiv(__numer, __denom);
S   }
N#endif
N
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || 1
Nextern _ARMABI_PURE __LONGLONG llabs(__LONGLONG /*j*/);
Xextern __declspec(__nothrow) __attribute__((const)) long long llabs(long long  );
N   /*
N    * computes the absolute value of a long long integer j. If the
N    * result cannot be represented, the behaviour is undefined.
N    * Returns: the absolute value.
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE __LONGLONG abs(__LONGLONG x) { return llabs(x); }
N#endif
N
Nextern _ARMABI_PURE lldiv_t lldiv(__LONGLONG /*numer*/, __LONGLONG /*denom*/);
Xextern __declspec(__nothrow) __attribute__((const)) lldiv_t lldiv(long long  , long long  );
N   /*
N    * computes the quotient and remainder of the division of the numerator
N    * numer by the denominator denom. If the division is inexact, the sign of
N    * the resulting quotient is that of the algebraic quotient, and the
N    * magnitude of the resulting quotient is the largest integer less than the
N    * magnitude of the algebraic quotient. If the result cannot be represented,
N    * the behaviour is undefined; otherwise, quot * denom + rem shall equal
N    * numer.
N    * Returns: a structure of type lldiv_t, comprising both the quotient and the
N    *          remainder. the structure shall contain the following members,
N    *          in either order.
N    *          long long quot; long long rem;
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE lldiv_t div(__LONGLONG __numer, __LONGLONG __denom) {
S       return lldiv(__numer, __denom);
S   }
N#endif
N#endif
N
N#if !(__ARM_NO_DEPRECATED_FUNCTIONS)
N/*
N * ARM real-time divide functions for guaranteed performance
N */
Ntypedef struct __sdiv32by16 { int quot, rem; } __sdiv32by16;
Ntypedef struct __udiv32by16 { unsigned int quot, rem; } __udiv32by16;
N   /* used int so that values return in separate regs, although 16-bit */
Ntypedef struct __sdiv64by32 { int rem, quot; } __sdiv64by32;
N
N__value_in_regs extern _ARMABI_PURE __sdiv32by16 __rt_sdiv32by16(
X__value_in_regs extern __declspec(__nothrow) __attribute__((const)) __sdiv32by16 __rt_sdiv32by16(
N     int /*numer*/,
N     short int /*denom*/);
N   /*
N    * Signed divide: (16-bit quot), (16-bit rem) = (32-bit) / (16-bit)
N    */
N__value_in_regs extern _ARMABI_PURE __udiv32by16 __rt_udiv32by16(
X__value_in_regs extern __declspec(__nothrow) __attribute__((const)) __udiv32by16 __rt_udiv32by16(
N     unsigned int /*numer*/,
N     unsigned short /*denom*/);
N   /*
N    * Unsigned divide: (16-bit quot), (16-bit rem) = (32-bit) / (16-bit)
N    */
N__value_in_regs extern _ARMABI_PURE __sdiv64by32 __rt_sdiv64by32(
X__value_in_regs extern __declspec(__nothrow) __attribute__((const)) __sdiv64by32 __rt_sdiv64by32(
N     int /*numer_h*/, unsigned int /*numer_l*/,
N     int /*denom*/);
N   /*
N    * Signed divide: (32-bit quot), (32-bit rem) = (64-bit) / (32-bit)
N    */
N#endif
N
N/*
N * ARM floating-point mask/status function (for both hardfp and softfp)
N */
Nextern _ARMABI unsigned int __fp_status(unsigned int /*mask*/, unsigned int /*flags*/);
Xextern __declspec(__nothrow) unsigned int __fp_status(unsigned int  , unsigned int  );
N   /*
N    * mask and flags are bit-fields which correspond directly to the
N    * floating point status register in the FPE/FPA and fplib.  
N    * __fp_status returns the current value of the status register,
N    * and also sets the writable bits of the word
N    * (the exception control and flag bytes) to:
N    *
N    *     new = (old & ~mask) ^ flags;
N    */
N#define __fpsr_IXE  0x100000
N#define __fpsr_UFE  0x80000
N#define __fpsr_OFE  0x40000
N#define __fpsr_DZE  0x20000
N#define __fpsr_IOE  0x10000
N
N#define __fpsr_IXC  0x10
N#define __fpsr_UFC  0x8
N#define __fpsr_OFC  0x4
N#define __fpsr_DZC  0x2
N#define __fpsr_IOC  0x1
N
N/*
N * Multibyte Character Functions.
N * The behaviour of the multibyte character functions is affected by the
N * LC_CTYPE category of the current locale. For a state-dependent encoding,
N * each function is placed into its initial state by a call for which its
N * character pointer argument, s, is a null pointer. Subsequent calls with s
N * as other than a null pointer cause the internal state of the function to be
N * altered as necessary. A call with s as a null pointer causes these functions
N * to return a nonzero value if encodings have state dependency, and a zero
N * otherwise. After the LC_CTYPE category is changed, the shift state of these
N * functions is indeterminate.
N */
Nextern _ARMABI int mblen(const char * /*s*/, size_t /*n*/);
Xextern __declspec(__nothrow) int mblen(const char *  , size_t  );
N   /*
N    * If s is not a null pointer, the mblen function determines the number of
N    * bytes compromising the multibyte character pointed to by s. Except that
N    * the shift state of the mbtowc function is not affected, it is equivalent
N    * to   mbtowc((wchar_t *)0, s, n);
N    * Returns: If s is a null pointer, the mblen function returns a nonzero or
N    *          zero value, if multibyte character encodings, respectively, do
N    *          or do not have state-dependent encodings. If s is not a null
N    *          pointer, the mblen function either returns a 0 (if s points to a
N    *          null character), or returns the number of bytes that compromise
N    *          the multibyte character (if the next n of fewer bytes form a
N    *          valid multibyte character), or returns -1 (they do not form a
N    *          valid multibyte character).
N    */
Nextern _ARMABI int mbtowc(wchar_t * __restrict /*pwc*/,
Xextern __declspec(__nothrow) int mbtowc(wchar_t * __restrict  ,
N                   const char * __restrict /*s*/, size_t /*n*/);
N   /*
N    * If s is not a null pointer, the mbtowc function determines the number of
N    * bytes that compromise the multibyte character pointed to by s. It then
N    * determines the code for value of type wchar_t that corresponds to that
N    * multibyte character. (The value of the code corresponding to the null
N    * character is zero). If the multibyte character is valid and pwc is not a
N    * null pointer, the mbtowc function stores the code in the object pointed
N    * to by pwc. At most n bytes of the array pointed to by s will be examined.
N    * Returns: If s is a null pointer, the mbtowc function returns a nonzero or
N    *          zero value, if multibyte character encodings, respectively, do
N    *          or do not have state-dependent encodings. If s is not a null
N    *          pointer, the mbtowc function either returns a 0 (if s points to
N    *          a null character), or returns the number of bytes that
N    *          compromise the converted multibyte character (if the next n of
N    *          fewer bytes form a valid multibyte character), or returns -1
N    *          (they do not form a valid multibyte character).
N    */
Nextern _ARMABI int wctomb(char * /*s*/, wchar_t /*wchar*/);
Xextern __declspec(__nothrow) int wctomb(char *  , wchar_t  );
N   /*
N    * determines the number of bytes need to represent the multibyte character
N    * corresponding to the code whose value is wchar (including any change in
N    * shift state). It stores the multibyte character representation in the
N    * array object pointed to by s (if s is not a null pointer). At most
N    * MB_CUR_MAX characters are stored. If the value of wchar is zero, the
N    * wctomb function is left in the initial shift state).
N    * Returns: If s is a null pointer, the wctomb function returns a nonzero or
N    *          zero value, if multibyte character encodings, respectively, do
N    *          or do not have state-dependent encodings. If s is not a null
N    *          pointer, the wctomb function returns a -1 if the value of wchar
N    *          does not correspond to a valid multibyte character, or returns
N    *          the number of bytes that compromise the multibyte character
N    *          corresponding to the value of wchar.
N    */
N
N/*
N * Multibyte String Functions.
N * The behaviour of the multibyte string functions is affected by the LC_CTYPE
N * category of the current locale.
N */
Nextern _ARMABI size_t mbstowcs(wchar_t * __restrict /*pwcs*/,
Xextern __declspec(__nothrow) size_t mbstowcs(wchar_t * __restrict  ,
N                      const char * __restrict /*s*/, size_t /*n*/) __attribute__((__nonnull__(2)));
N   /*
N    * converts a sequence of multibyte character that begins in the initial
N    * shift state from the array pointed to by s into a sequence of
N    * corresponding codes and stores not more than n codes into the array
N    * pointed to by pwcs. No multibyte character that follow a null character
N    * (which is converted into a code with value zero) will be examined or
N    * converted. Each multibyte character is converted as if by a call to
N    * mbtowc function, except that the shift state of the mbtowc function is
N    * not affected. No more than n elements will be modified in the array
N    * pointed to by pwcs. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: If an invalid multibyte character is encountered, the mbstowcs
N    *          function returns (size_t)-1. Otherwise, the mbstowcs function
N    *          returns the number of array elements modified, not including
N    *          a terminating zero code, if any.
N    */
Nextern _ARMABI size_t wcstombs(char * __restrict /*s*/,
Xextern __declspec(__nothrow) size_t wcstombs(char * __restrict  ,
N                      const wchar_t * __restrict /*pwcs*/, size_t /*n*/) __attribute__((__nonnull__(2)));
N   /*
N    * converts a sequence of codes that correspond to multibyte characters
N    * from the array pointed to by pwcs into a sequence of multibyte
N    * characters that begins in the initial shift state and stores these
N    * multibyte characters into the array pointed to by s, stopping if a
N    * multibyte character would exceed the limit of n total bytes or if a
N    * null character is stored. Each code is converted as if by a call to the
N    * wctomb function, except that the shift state of the wctomb function is
N    * not affected. No more than n elements will be modified in the array
N    * pointed to by s. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: If a code is encountered that does not correspond to a valid
N    *          multibyte character, the wcstombs function returns (size_t)-1.
N    *          Otherwise, the wcstombs function returns the number of bytes
N    *          modified, not including a terminating null character, if any.
N    */
N
Nextern _ARMABI void __use_realtime_heap(void);
Xextern __declspec(__nothrow) void __use_realtime_heap(void);
Nextern _ARMABI void __use_realtime_division(void);
Xextern __declspec(__nothrow) void __use_realtime_division(void);
Nextern _ARMABI void __use_two_region_memory(void);
Xextern __declspec(__nothrow) void __use_two_region_memory(void);
Nextern _ARMABI void __use_no_heap(void);
Xextern __declspec(__nothrow) void __use_no_heap(void);
Nextern _ARMABI void __use_no_heap_region(void);
Xextern __declspec(__nothrow) void __use_no_heap_region(void);
N
Nextern _ARMABI char const *__C_library_version_string(void);
Xextern __declspec(__nothrow) char const *__C_library_version_string(void);
Nextern _ARMABI int __C_library_version_number(void);
Xextern __declspec(__nothrow) int __C_library_version_number(void);
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDLIB_DECLS */
N
N  #if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X  #if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S    #define _AEABI_PORTABLE
N  #endif
N
N  #ifdef __cplusplus
S    #ifndef __STDLIB_NO_EXPORTS
S      #if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
S        using ::std::atoll;
S        using ::std::lldiv_t;
S      #endif /* !defined(__STRICT_ANSI__) || __USE_C99_STDLIB */
S      using ::std::div_t;
S      using ::std::ldiv_t;
S      using ::std::atof;
S      using ::std::atoi;
S      using ::std::atol;
S      using ::std::strtod;
S#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
S      using ::std::strtof;
S      using ::std::strtold;
S#endif
S      using ::std::strtol;
S      using ::std::strtoul;
S      using ::std::strtoll;
S      using ::std::strtoull;
S      using ::std::rand;
S      using ::std::srand;
S      using ::std::_rand_state;
S      using ::std::_rand_r;
S      using ::std::_srand_r;
S      using ::std::_ANSI_rand_state;
S      using ::std::_ANSI_rand_r;
S      using ::std::_ANSI_srand_r;
S      using ::std::calloc;
S      using ::std::free;
S      using ::std::malloc;
S      using ::std::realloc;
S#if !defined(__STRICT_ANSI__)
S      using ::std::posix_memalign;
S#endif
S      using ::std::__heapprt;
S      using ::std::__heapstats;
S      using ::std::__heapvalid;
S      using ::std::abort;
S      using ::std::atexit;
S      using ::std::exit;
S      using ::std::_Exit;
S      using ::std::getenv;
S      using ::std::system;
S      using ::std::bsearch;
S      using ::std::qsort;
S      using ::std::abs;
S      using ::std::div;
S      using ::std::labs;
S      using ::std::ldiv;
S      #if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
S        using ::std::llabs;
S        using ::std::lldiv;
S      #endif /* !defined(__STRICT_ANSI__) || __USE_C99_STDLIB */
S#if !(__ARM_NO_DEPRECATED_FUNCTIONS)
S      using ::std::__sdiv32by16;
S      using ::std::__udiv32by16;
S      using ::std::__sdiv64by32;
S      using ::std::__rt_sdiv32by16;
S      using ::std::__rt_udiv32by16;
S      using ::std::__rt_sdiv64by32;
S#endif
S      using ::std::__fp_status;
S      using ::std::mblen;
S      using ::std::mbtowc;
S      using ::std::wctomb;
S      using ::std::mbstowcs;
S      using ::std::wcstombs;
S      using ::std::__use_realtime_heap;
S      using ::std::__use_realtime_division;
S      using ::std::__use_two_region_memory;
S      using ::std::__use_no_heap;
S      using ::std::__use_no_heap_region;
S      using ::std::__C_library_version_string;
S      using ::std::__C_library_version_number;
S      using ::std::size_t;
S      using ::std::__aeabi_MB_CUR_MAX;
S    #endif /* __STDLIB_NO_EXPORTS */
N  #endif /* __cplusplus */
N
N#undef __LONGLONG
N
N#endif /* __stdlib_h */
N
N/* end of stdlib.h */
L 6 "app\bim_uart.c" 2
N#include <stddef.h>    // standard definitions
N#include <stdint.h>    // standard integer definition
N#include <stdbool.h>   // boolean definition
N#include "string.h"
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\string.h" 1
N/* string.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.11 */
N/* Copyright (C) Codemist Ltd., 1988-1993.                        */
N/* Copyright 1991-1993 ARM Limited. All rights reserved.          */
N/* version 0.04 */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N */
N
N/*
N * string.h declares one type and several functions, and defines one macro
N * useful for manipulating character arrays and other objects treated as
N * character arrays. Various methods are used for determining the lengths of
N * the arrays, but in all cases a char * or void * argument points to the
N * initial (lowest addresses) character of the array. If an array is written
N * beyond the end of an object, the behaviour is undefined.
N */
N
N#ifndef __string_h
N#define __string_h
N#define __ARMCLIB_VERSION 5060044
N
N#define _ARMABI __declspec(__nothrow)
N
N  #ifndef __STRING_DECLS
N  #define __STRING_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S        namespace std {
S        #define __CLIBNS std::
S        extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 0L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N#elif !defined(__size_t)
S  #define __size_t 1
S  #if __sizeof_ptr == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
S  #else
S    typedef unsigned int size_t;   /* see <stddef.h> */
S  #endif
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
Nextern _ARMABI void *memcpy(void * __restrict /*s1*/,
Xextern __declspec(__nothrow) void *memcpy(void * __restrict  ,
N                    const void * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies n characters from the object pointed to by s2 into the object
N    * pointed to by s1. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI void *memmove(void * /*s1*/,
Xextern __declspec(__nothrow) void *memmove(void *  ,
N                    const void * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies n characters from the object pointed to by s2 into the object
N    * pointed to by s1. Copying takes place as if the n characters from the
N    * object pointed to by s2 are first copied into a temporary array of n
N    * characters that does not overlap the objects pointed to by s1 and s2,
N    * and then the n characters from the temporary array are copied into the
N    * object pointed to by s1.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strcpy(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strcpy(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies the string pointed to by s2 (including the terminating nul
N    * character) into the array pointed to by s1. If copying takes place
N    * between objects that overlap, the behaviour is undefined.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strncpy(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strncpy(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies not more than n characters (characters that follow a null
N    * character are not copied) from the array pointed to by s2 into the array
N    * pointed to by s1. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: the value of s1.
N    */
N
Nextern _ARMABI char *strcat(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strcat(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * appends a copy of the string pointed to by s2 (including the terminating
N    * null character) to the end of the string pointed to by s1. The initial
N    * character of s2 overwrites the null character at the end of s1.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strncat(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strncat(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * appends not more than n characters (a null character and characters that
N    * follow it are not appended) from the array pointed to by s2 to the end of
N    * the string pointed to by s1. The initial character of s2 overwrites the
N    * null character at the end of s1. A terminating null character is always
N    * appended to the result.
N    * Returns: the value of s1.
N    */
N
N/*
N * The sign of a nonzero value returned by the comparison functions is
N * determined by the sign of the difference between the values of the first
N * pair of characters (both interpreted as unsigned char) that differ in the
N * objects being compared.
N */
N
Nextern _ARMABI int memcmp(const void * /*s1*/, const void * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int memcmp(const void *  , const void *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the first n characters of the object pointed to by s1 to the
N    * first n characters of the object pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the object pointed to by s1 is greater than, equal to, or
N    *          less than the object pointed to by s2.
N    */
Nextern _ARMABI int strcmp(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcmp(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strncmp(const char * /*s1*/, const char * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strncmp(const char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares not more than n characters (characters that follow a null
N    * character are not compared) from the array pointed to by s1 to the array
N    * pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strcasecmp(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcasecmp(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2,
N    * case-insensitively as defined by the current locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strncasecmp(const char * /*s1*/, const char * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strncasecmp(const char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares not more than n characters (characters that follow a null
N    * character are not compared) from the array pointed to by s1 to the array
N    * pointed to by s2, case-insensitively as defined by the current locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strcoll(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcoll(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2, both
N    * interpreted as appropriate to the LC_COLLATE category of the current
N    * locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2 when both are interpreted
N    *          as appropriate to the current locale.
N    */
N
Nextern _ARMABI size_t strxfrm(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) size_t strxfrm(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(2)));
N   /*
N    * transforms the string pointed to by s2 and places the resulting string
N    * into the array pointed to by s1. The transformation function is such that
N    * if the strcmp function is applied to two transformed strings, it returns
N    * a value greater than, equal to or less than zero, corresponding to the
N    * result of the strcoll function applied to the same two original strings.
N    * No more than n characters are placed into the resulting array pointed to
N    * by s1, including the terminating null character. If n is zero, s1 is
N    * permitted to be a null pointer. If copying takes place between objects
N    * that overlap, the behaviour is undefined.
N    * Returns: The length of the transformed string is returned (not including
N    *          the terminating null character). If the value returned is n or
N    *          more, the contents of the array pointed to by s1 are
N    *          indeterminate.
N    */
N
N
N#ifdef __cplusplus
Sextern _ARMABI const void *memchr(const void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Sextern "C++" void *memchr(void * __s, int __c, size_t __n) __attribute__((__nonnull__(1)));
Sextern "C++" inline void *memchr(void * __s, int __c, size_t __n)
S    { return const_cast<void *>(memchr(const_cast<const void *>(__s), __c, __n)); }
N#else
Nextern _ARMABI void *memchr(const void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void *memchr(const void *  , int  , size_t  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the first occurence of c (converted to an unsigned char) in the
N    * initial n characters (each interpreted as unsigned char) of the object
N    * pointed to by s.
N    * Returns: a pointer to the located character, or a null pointer if the
N    *          character does not occur in the object.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Sextern "C++" char *strchr(char * __s, int __c) __attribute__((__nonnull__(1)));
Sextern "C++" inline char *strchr(char * __s, int __c)
S    { return const_cast<char *>(strchr(const_cast<const char *>(__s), __c)); }
N#else
Nextern _ARMABI char *strchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *strchr(const char *  , int  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the first occurence of c (converted to an char) in the string
N    * pointed to by s (including the terminating null character).
N    * Returns: a pointer to the located character, or a null pointer if the
N    *          character does not occur in the string.
N    */
N
Nextern _ARMABI size_t strcspn(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strcspn(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * computes the length of the initial segment of the string pointed to by s1
N    * which consists entirely of characters not from the string pointed to by
N    * s2. The terminating null character is not considered part of s2.
N    * Returns: the length of the segment.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strpbrk(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Sextern "C++" char *strpbrk(char * __s1, const char * __s2) __attribute__((__nonnull__(1,2)));
Sextern "C++" inline char *strpbrk(char * __s1, const char * __s2)
S    { return const_cast<char *>(strpbrk(const_cast<const char *>(__s1), __s2)); }
N#else
Nextern _ARMABI char *strpbrk(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strpbrk(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N#endif
N   /*
N    * locates the first occurence in the string pointed to by s1 of any
N    * character from the string pointed to by s2.
N    * Returns: returns a pointer to the character, or a null pointer if no
N    *          character form s2 occurs in s1.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strrchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Sextern "C++" char *strrchr(char * __s, int __c) __attribute__((__nonnull__(1)));
Sextern "C++" inline char *strrchr(char * __s, int __c)
S    { return const_cast<char *>(strrchr(const_cast<const char *>(__s), __c)); }
N#else
Nextern _ARMABI char *strrchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *strrchr(const char *  , int  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the last occurence of c (converted to a char) in the string
N    * pointed to by s. The terminating null character is considered part of
N    * the string.
N    * Returns: returns a pointer to the character, or a null pointer if c does
N    *          not occur in the string.
N    */
N
Nextern _ARMABI size_t strspn(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strspn(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * computes the length of the initial segment of the string pointed to by s1
N    * which consists entirely of characters from the string pointed to by S2
N    * Returns: the length of the segment.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strstr(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Sextern "C++" char *strstr(char * __s1, const char * __s2) __attribute__((__nonnull__(1,2)));
Sextern "C++" inline char *strstr(char * __s1, const char * __s2)
S    { return const_cast<char *>(strstr(const_cast<const char *>(__s1), __s2)); }
N#else
Nextern _ARMABI char *strstr(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strstr(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N#endif
N   /*
N    * locates the first occurence in the string pointed to by s1 of the
N    * sequence of characters (excluding the terminating null character) in the
N    * string pointed to by s2.
N    * Returns: a pointer to the located string, or a null pointer if the string
N    *          is not found.
N    */
N
Nextern _ARMABI char *strtok(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) char *strtok(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(2)));
Nextern _ARMABI char *_strtok_r(char * /*s1*/, const char * /*s2*/, char ** /*ptr*/) __attribute__((__nonnull__(2,3)));
Xextern __declspec(__nothrow) char *_strtok_r(char *  , const char *  , char **  ) __attribute__((__nonnull__(2,3)));
N#ifndef __STRICT_ANSI__
Nextern _ARMABI char *strtok_r(char * /*s1*/, const char * /*s2*/, char ** /*ptr*/) __attribute__((__nonnull__(2,3)));
Xextern __declspec(__nothrow) char *strtok_r(char *  , const char *  , char **  ) __attribute__((__nonnull__(2,3)));
N#endif
N   /*
N    * A sequence of calls to the strtok function breaks the string pointed to
N    * by s1 into a sequence of tokens, each of which is delimited by a
N    * character from the string pointed to by s2. The first call in the
N    * sequence has s1 as its first argument, and is followed by calls with a
N    * null pointer as their first argument. The separator string pointed to by
N    * s2 may be different from call to call.
N    * The first call in the sequence searches for the first character that is
N    * not contained in the current separator string s2. If no such character
N    * is found, then there are no tokens in s1 and the strtok function returns
N    * a null pointer. If such a character is found, it is the start of the
N    * first token.
N    * The strtok function then searches from there for a character that is
N    * contained in the current separator string. If no such character is found,
N    * the current token extends to the end of the string pointed to by s1, and
N    * subsequent searches for a token will fail. If such a character is found,
N    * it is overwritten by a null character, which terminates the current
N    * token. The strtok function saves a pointer to the following character,
N    * from which the next search for a token will start.
N    * Each subsequent call, with a null pointer as the value for the first
N    * argument, starts searching from the saved pointer and behaves as
N    * described above.
N    * Returns: pointer to the first character of a token, or a null pointer if
N    *          there is no token.
N    *
N    * strtok_r() is a common extension which works exactly like
N    * strtok(), but instead of storing its state in a hidden
N    * library variable, requires the user to pass in a pointer to a
N    * char * variable which will be used instead. Any sequence of
N    * calls to strtok_r() passing the same char ** pointer should
N    * behave exactly like the corresponding sequence of calls to
N    * strtok(). This means that strtok_r() can safely be used in
N    * multi-threaded programs, and also that you can tokenise two
N    * strings in parallel.
N    */
N
Nextern _ARMABI void *memset(void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void *memset(void *  , int  , size_t  ) __attribute__((__nonnull__(1)));
N   /*
N    * copies the value of c (converted to an unsigned char) into each of the
N    * first n charactes of the object pointed to by s.
N    * Returns: the value of s.
N    */
Nextern _ARMABI char *strerror(int /*errnum*/);
Xextern __declspec(__nothrow) char *strerror(int  );
N   /*
N    * maps the error number in errnum to an error message string.
N    * Returns: a pointer to the string, the contents of which are
N    *          implementation-defined. The array pointed to shall not be
N    *          modified by the program, but may be overwritten by a
N    *          subsequent call to the strerror function.
N    */
Nextern _ARMABI size_t strlen(const char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) size_t strlen(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * computes the length of the string pointed to by s.
N    * Returns: the number of characters that precede the terminating null
N    *          character.
N    */
N
Nextern _ARMABI size_t strlcpy(char * /*dst*/, const char * /*src*/, size_t /*len*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strlcpy(char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies the string src into the string dst, using no more than
N    * len bytes of dst. Always null-terminates dst _within the
N    * length len (i.e. will copy at most len-1 bytes of string plus
N    * a NUL), unless len is actually zero.
N    * 
N    * Return value is the length of the string that _would_ have
N    * been written, i.e. the length of src. Thus, the operation
N    * succeeded without truncation if and only if ret < len;
N    * otherwise, the value in ret tells you how big to make dst if
N    * you decide to reallocate it. (That value does _not_ include
N    * the NUL.)
N    * 
N    * This is a BSD-derived library extension, which we are
N    * permitted to declare in a standard header because ISO defines
N    * function names beginning with 'str' as reserved for future
N    * expansion of <string.h>.
N    */
N
Nextern _ARMABI size_t strlcat(char * /*dst*/, const char * /*src*/, size_t /*len*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strlcat(char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * concatenates the string src to the string dst, using no more
N    * than len bytes of dst. Always null-terminates dst _within the
N    * length len (i.e. will copy at most len-1 bytes of string plus
N    * a NUL), unless len is actually zero.
N    * 
N    * Return value is the length of the string that _would_ have
N    * been written, i.e. the length of src plus the original length
N    * of dst. Thus, the operation succeeded without truncation if
N    * and only if ret < len; otherwise, the value in ret tells you
N    * how big to make dst if you decide to reallocate it. (That
N    * value does _not_ include the NUL.)
N    * 
N    * If no NUL is encountered within the first len bytes of dst,
N    * then the length of dst is considered to have been equal to
N    * len for the purposes of the return value (as if there were a
N    * NUL at dst[len]). Thus, the return value in this case is len
N    * + strlen(src).
N    * 
N    * This is a BSD-derived library extension, which we are
N    * permitted to declare in a standard header because ISO defines
N    * function names beginning with 'str' as reserved for future
N    * expansion of <string.h>.
N    */
N
Nextern _ARMABI void _membitcpybl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpybl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpybb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpybb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpyhl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpyhl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpyhb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpyhb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpywl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpywl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpywb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpywb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovebl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovebl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovebb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovebb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovehl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovehl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovehb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovehb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovewl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovewl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovewb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovewb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
N    /*
N     * Copies or moves a piece of memory from one place to another,
N     * with one-bit granularity. So you can start or finish a copy
N     * part way through a byte, and you can copy between regions
N     * with different alignment within a byte.
N     * 
N     * All these functions have the same prototype: two void *
N     * pointers for destination and source, then two integers
N     * giving the bit offset from those pointers, and finally the
N     * number of bits to copy.
N     * 
N     * Just like memcpy and memmove, the "cpy" functions copy as
N     * fast as they can in the assumption that the memory regions
N     * do not overlap, while the "move" functions cope correctly
N     * with overlap.
N     *
N     * Treating memory as a stream of individual bits requires
N     * defining a convention about what order those bits are
N     * considered to be arranged in. The above functions support
N     * multiple conventions:
N     * 
N     *  - the "bl" functions consider the unit of memory to be the
N     *    byte, and consider the bits within each byte to be
N     *    arranged in little-endian fashion, so that the LSB comes
N     *    first. (For example, membitcpybl(a,b,0,7,1) would copy
N     *    the MSB of the byte at b to the LSB of the byte at a.)
N     * 
N     *  - the "bb" functions consider the unit of memory to be the
N     *    byte, and consider the bits within each byte to be
N     *    arranged in big-endian fashion, so that the MSB comes
N     *    first.
N     * 
N     *  - the "hl" functions consider the unit of memory to be the
N     *    16-bit halfword, and consider the bits within each word
N     *    to be arranged in little-endian fashion.
N     * 
N     *  - the "hb" functions consider the unit of memory to be the
N     *    16-bit halfword, and consider the bits within each word
N     *    to be arranged in big-endian fashion.
N     * 
N     *  - the "wl" functions consider the unit of memory to be the
N     *    32-bit word, and consider the bits within each word to be
N     *    arranged in little-endian fashion.
N     * 
N     *  - the "wb" functions consider the unit of memory to be the
N     *    32-bit word, and consider the bits within each word to be
N     *    arranged in big-endian fashion.
N     */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STRING_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STRING_NO_EXPORTS
S      using ::std::size_t;
S      using ::std::memcpy;
S      using ::std::memmove;
S      using ::std::strcpy;
S      using ::std::strncpy;
S      using ::std::strcat;
S      using ::std::strncat;
S      using ::std::memcmp;
S      using ::std::strcmp;
S      using ::std::strncmp;
S      using ::std::strcasecmp;
S      using ::std::strncasecmp;
S      using ::std::strcoll;
S      using ::std::strxfrm;
S      using ::std::memchr;
S      using ::std::strchr;
S      using ::std::strcspn;
S      using ::std::strpbrk;
S      using ::std::strrchr;
S      using ::std::strspn;
S      using ::std::strstr;
S      using ::std::strtok;
S#ifndef __STRICT_ANSI__
S      using ::std::strtok_r;
S#endif
S      using ::std::_strtok_r;
S      using ::std::memset;
S      using ::std::strerror;
S      using ::std::strlen;
S      using ::std::strlcpy;
S      using ::std::strlcat;
S      using ::std::_membitcpybl;
S      using ::std::_membitcpybb;
S      using ::std::_membitcpyhl;
S      using ::std::_membitcpyhb;
S      using ::std::_membitcpywl;
S      using ::std::_membitcpywb;
S      using ::std::_membitmovebl;
S      using ::std::_membitmovebb;
S      using ::std::_membitmovehl;
S      using ::std::_membitmovehb;
S      using ::std::_membitmovewl;
S      using ::std::_membitmovewb;
S    #endif /* __STRING_NO_EXPORTS */
N  #endif /* __cplusplus */
N
N#endif
N
N/* end of string.h */
N
L 10 "app\bim_uart.c" 2
N#include <stdlib.h>
N#include  <stdarg.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\stdarg.h" 1
N/* stdarg.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.8 */
N/* Copyright (C) Codemist Ltd., 1988                            */
N/* Copyright (C) ARM Ltd., 1991-1999. All rights reserved */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: agrant $
N */
N
N#ifndef __stdarg_h
N#define __stdarg_h
N#define __ARMCLIB_VERSION 5060044
N
N  #ifndef __STDARG_DECLS
N  #define __STDARG_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS ::std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N/*
N * stdarg.h declares a type and defines macros for advancing through a
N * list of arguments whose number and types are not known to the called
N * function when it is translated. A function may be called with a variable
N * number of arguments of differing types. Its parameter list contains one or
N * more parameters. The rightmost parameter plays a special role in the access
N * mechanism, and will be called parmN in this description.
N */
N
N/* N.B. <stdio.h> is required to declare vfprintf() without defining      */
N/* va_list.  Clearly the type __va_list there must keep in step.          */
N#ifdef __clang__
S  typedef __builtin_va_list va_list;
S  #define va_start(ap, param) __builtin_va_start(ap, param)
S  #define va_end(ap)          __builtin_va_end(ap)
S  #define va_arg(ap, type)    __builtin_va_arg(ap, type)
S  #if __STDC_VERSION__ >= 199900L || __cplusplus >= 201103L || !defined(__STRICT_ANSI__)
S  #define va_copy(dest, src)  __builtin_va_copy(dest, src)
S  #endif
N#else
N  #ifdef __TARGET_ARCH_AARCH64
S    typedef struct __va_list {
S      void *__stack;
S      void *__gr_top;
S      void *__vr_top;
S      int __gr_offs;
S      int __vr_offs;
S    } va_list;
N  #else
N    typedef struct __va_list { void *__ap; } va_list;
N  #endif
N   /*
N    * an array type suitable for holding information needed by the macro va_arg
N    * and the function va_end. The called function shall declare a variable
N    * (referred to as ap) having type va_list. The variable ap may be passed as
N    * an argument to another function.
N    * Note: va_list is an array type so that when an object of that type
N    * is passed as an argument it gets passed by reference.
N    */
N  #define va_start(ap, parmN) __va_start(ap, parmN)
N
N   /*
N    * The va_start macro shall be executed before any access to the unnamed
N    * arguments. The parameter ap points to an object that has type va_list.
N    * The va_start macro initialises ap for subsequent use by va_arg and
N    * va_end. The parameter parmN is the identifier of the rightmost parameter
N    * in the variable parameter list in the function definition (the one just
N    * before the '...'). If the parameter parmN is declared with the register
N    * storage class an error is given.
N    * If parmN is a narrow type (char, short, float) an error is given in
N    * strict ANSI mode, or a warning otherwise.
N    * Returns: no value.
N    */
N  #define va_arg(ap, type) __va_arg(ap, type)
N
N   /*
N    * The va_arg macro expands to an expression that has the type and value of
N    * the next argument in the call. The parameter ap shall be the same as the
N    * va_list ap initialised by va_start. Each invocation of va_arg modifies
N    * ap so that successive arguments are returned in turn. The parameter
N    * 'type' is a type name such that the type of a pointer to an object that
N    * has the specified type can be obtained simply by postfixing a * to
N    * 'type'. If type is a narrow type, an error is given in strict ANSI
N    * mode, or a warning otherwise. If the type is an array or function type,
N    * an error is given.
N    * In non-strict ANSI mode, 'type' is allowed to be any expression.
N    * Returns: The first invocation of the va_arg macro after that of the
N    *          va_start macro returns the value of the argument after that
N    *          specified by parmN. Successive invocations return the values of
N    *          the remaining arguments in succession.
N    *          The result is cast to 'type', even if 'type' is narrow.
N    */
N
N#define __va_copy(dest, src) ((void)((dest) = (src)))
N
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 199901L <= 199901L) || (0L && 201103L <= __cplusplus)
N   /* va_copy is in C99 and non-strict C90 and non-strict C++
N    * __va_copy is always present.
N    */
N  #define va_copy(dest, src) ((void)((dest) = (src)))
N
N   /* The va_copy macro makes the va_list dest be a copy of
N    * the va_list src, as if the va_start macro had been applied
N    * to it followed by the same sequence of uses of the va_arg
N    * macro as had previously been used to reach the present state
N    * of src.
N    */
N#endif
N
N#define va_end(ap) __va_end(ap)
N   /*
N    * The va_end macro facilitates a normal return from the function whose
N    * variable argument list was referenced by the expansion of va_start that
N    * initialised the va_list ap. If the va_end macro is not invoked before
N    * the return, the behaviour is undefined.
N    * Returns: no value.
N    */
N#endif /* __clang__ */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N
N    #ifdef __GNUC__
S     /* be cooperative with glibc */
S     typedef __CLIBNS va_list __gnuc_va_list;
S     #define __GNUC_VA_LIST
S     #undef __need___va_list
N    #endif
N
N  #endif /* __STDARG_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STDARG_NO_EXPORTS
S      using ::std::va_list;
S    #endif
N  #endif /* __cplusplus */
N#endif
N
N/* end of stdarg.h */
N
L 12 "app\bim_uart.c" 2
N#include  <stdio.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\stdio.h" 1
N/* stdio.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.9 */
N/* Copyright (C) Codemist Ltd., 1988-1993                       */
N/* Copyright 1991-1998 ARM Limited. All rights reserved.        */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: sdouglas $
N */
N
N/*
N * stdio.h declares two types, several macros, and many functions for
N * performing input and output. For a discussion on Streams and Files
N * refer to sections 4.9.2 and 4.9.3 in the above ANSI draft, or to a
N * modern textbook on C.
N */
N
N#ifndef __stdio_h
N#define __stdio_h
N#define __ARMCLIB_VERSION 5060044
N
N/*
N * Depending on compiler version __int64 or __INT64_TYPE__ should be defined.
N */
N#ifndef __int64
N  #ifdef __INT64_TYPE__
S    #define __int64 __INT64_TYPE__
N  #endif
N  /* On some architectures neither of these may be defined - if so, fall
N     through and error out if used. */
N#endif
N
N
N#define _ARMABI __declspec(__nothrow)
N
N  #ifndef __STDIO_DECLS
N  #define __STDIO_DECLS
N
N    #undef __CLIBNS
N    #ifdef __cplusplus
S      namespace std {
S      #define __CLIBNS ::std::
S        extern "C" {
N    #else /* ndef __cplusplus */
N      #define __CLIBNS
N    #endif /* ndef __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__) || !defined(__size_t)
X#if 0L || !0L || !0L
N /* always defined in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N  #if !defined(__cplusplus) && defined(__STRICT_ANSI__)
X  #if !0L && 0L
S    #define __size_t 1
N  #endif
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
N/* ANSI forbids va_list to be defined here */
N/* keep in step with <stdarg.h> and <wchar.h> */
N#if !defined(__va_list) && (defined(__cplusplus) || !defined(__STRICT_ANSI__) || !defined(__va_list_defined))
X#if !0L && (0L || !0L || !0L)
N/* always defined in C++ and non-strict C for consistency of debug info */
N  #ifdef __clang__
S    typedef __builtin_va_list __va_list;
N  #else
N    typedef struct __va_list __va_list;
N  #endif
N  #if !defined(__cplusplus) && defined(__STRICT_ANSI__)
X  #if !0L && 0L
S    #define __va_list_defined 1
N  #endif
N#endif
N
N   /*
N    * If the compiler supports signalling nans as per N965 then it
N    * will define __SUPPORT_SNAN__, in which case a user may define
N    * _WANT_SNAN in order to obtain compliant versions of the printf
N    * and scanf families of functions
N    */
N#if defined(__SUPPORT_SNAN__) && defined(_WANT_SNAN)
X#if 0L && 0L
S#pragma import(__use_snan)
N#endif
N
Ntypedef struct __fpos_t_struct {
N    unsigned __int64 __pos;
N    /*
N     * this structure is equivalent to an mbstate_t, but we're not
N     * allowed to actually define the type name `mbstate_t' within
N     * stdio.h
N     */
N    struct {
N        unsigned int __state1, __state2;
N    } __mbstate;
N} fpos_t;
N   /*
N    * fpos_t is an object capable of recording all information needed to
N    * specify uniquely every position within a file.
N    */
N
N#define _SYS_OPEN 16
N   /* _SYS_OPEN defines a limit on the number of open files that is imposed
N    * by this C library
N    */
N
Ntypedef struct __FILE FILE;
N   /*
N    * FILE is an object capable of recording all information needed to control
N    * a stream, such as its file position indicator, a pointer to its
N    * associated buffer, an error indicator that records whether a read/write
N    * error has occurred and an end-of-file indicator that records whether the
N    * end-of-file has been reached.
N    * Its structure is not made known to library clients.
N    */
N
N#if defined(__STRICT_ANSI__) && !__FILE_INCOMPLETE
X#if 0L && !__FILE_INCOMPLETE
Sstruct __FILE {
S    union {
S        long __FILE_alignment;
S#ifdef __TARGET_ARCH_AARCH64
S        char __FILE_size[136];
S#else /* __TARGET_ARCH_AARCH64 */
S        char __FILE_size[84];
S#endif /* __TARGET_ARCH_AARCH64 */
S    } __FILE_opaque;
S};
S    /*
S     * FILE must be an object type (C99 - 7.19.1) and an object type fully
S     * describes an object [including its static size] (C99 - 6.2.5).
S     * This definition is a placeholder which matches the struct __FILE in
S     * size and alignment as used internally by libc.
S     */
N#endif
N
N
Nextern FILE __stdin, __stdout, __stderr;
Nextern FILE *__aeabi_stdin, *__aeabi_stdout, *__aeabi_stderr;
N
N#if _AEABI_PORTABILITY_LEVEL != 0 || (!defined _AEABI_PORTABILITY_LEVEL && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
X#if _AEABI_PORTABILITY_LEVEL != 0 || (!0L && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
S#define stdin  (__CLIBNS __aeabi_stdin)
S   /* pointer to a FILE object associated with standard input stream */
S#define stdout (__CLIBNS __aeabi_stdout)
S   /* pointer to a FILE object associated with standard output stream */
S#define stderr (__CLIBNS __aeabi_stderr)
S   /* pointer to a FILE object associated with standard error stream */
Sextern const int __aeabi_IOFBF;
S#define _IOFBF (__CLIBNS __aeabi_IOFBF)
Sextern const int __aeabi_IONBF;
S#define _IONBF (__CLIBNS __aeabi_IONBF)
Sextern const int __aeabi_IOLBF;
S#define _IOLBF (__CLIBNS __aeabi_IOLBF)
Sextern const int __aeabi_BUFSIZ;
S#define BUFSIZ (__CLIBNS __aeabi_BUFSIZ)
Sextern const int __aeabi_FOPEN_MAX;
S#define FOPEN_MAX (__CLIBNS __aeabi_FOPEN_MAX)
Sextern const int __aeabi_TMP_MAX;
S#define TMP_MAX (__CLIBNS __aeabi_TMP_MAX)
Sextern const int __aeabi_FILENAME_MAX;
S#define FILENAME_MAX (__CLIBNS __aeabi_FILENAME_MAX)
Sextern const int __aeabi_L_tmpnam;
S#define L_tmpnam (__CLIBNS __aeabi_L_tmpnam)
N#else
N#define stdin  (&__CLIBNS __stdin)
N   /* pointer to a FILE object associated with standard input stream */
N#define stdout (&__CLIBNS __stdout)
N   /* pointer to a FILE object associated with standard output stream */
N#define stderr (&__CLIBNS __stderr)
N   /* pointer to a FILE object associated with standard error stream */
N
N#define _IOFBF           0x100 /* fully buffered IO */
N#define _IOLBF           0x200 /* line buffered IO */
N#define _IONBF           0x400 /* unbuffered IO */
N
N    /* Various default file IO buffer sizes */
N#define BUFSIZ       (512)  /* system buffer size (as used by setbuf) */
N
N#define FOPEN_MAX _SYS_OPEN
N   /*
N    * an integral constant expression that is the minimum number of files that
N    * this implementation guarantees can be open simultaneously.
N    */
N
N#define FILENAME_MAX 256
N   /*
N    * an integral constant expression that is the size of an array of char
N    * large enough to hold the longest filename string
N    */
N#define L_tmpnam FILENAME_MAX
N   /*
N    * an integral constant expression that is the size of an array of char
N    * large enough to hold a temporary file name string generated by the
N    * tmpnam function.
N    */
N#define TMP_MAX 256
N   /*
N    * an integral constant expression that is the minimum number of unique
N    * file names that shall be generated by the tmpnam function.
N    */
N
N#endif
N
N#define EOF      (-1)
N   /*
N    * negative integral constant, indicates end-of-file, that is, no more input
N    * from a stream.
N    */
N
N#define SEEK_SET 0 /* start of stream (see fseek) */
N#define SEEK_CUR 1 /* current position in stream (see fseek) */
N#define SEEK_END 2 /* end of stream (see fseek) */
N
N    /*
N     * _IOBIN is the flag passed to _sys_write to denote a binary
N     * file.
N     */
N#define _IOBIN            0x04     /* binary stream */
N
N#define __STDIN_BUFSIZ  (64)  /* default stdin buffer size */
N#define __STDOUT_BUFSIZ (64)  /* default stdout buffer size */
N#define __STDERR_BUFSIZ (16)  /* default stderr buffer size */
N
Nextern _ARMABI int remove(const char * /*filename*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int remove(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * causes the file whose name is the string pointed to by filename to be
N    * removed. Subsequent attempts to open the file will fail, unless it is
N    * created anew. If the file is open, the behaviour of the remove function
N    * is implementation-defined.
N    * Returns: zero if the operation succeeds, nonzero if it fails.
N    */
Nextern _ARMABI int rename(const char * /*old*/, const char * /*new*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int rename(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * causes the file whose name is the string pointed to by old to be
N    * henceforth known by the name given by the string pointed to by new. The
N    * file named old is effectively removed. If a file named by the string
N    * pointed to by new exists prior to the call of the rename function, the
N    * behaviour is implementation-defined.
N    * Returns: zero if the operation succeeds, nonzero if it fails, in which
N    *          case if the file existed previously it is still known by its
N    *          original name.
N    */
Nextern _ARMABI FILE *tmpfile(void);
Xextern __declspec(__nothrow) FILE *tmpfile(void);
N   /*
N    * creates a temporary binary file that will be automatically removed when
N    * it is closed or at program termination. The file is opened for update.
N    * Returns: a pointer to the stream of the file that it created. If the file
N    *          cannot be created, a null pointer is returned.
N    */
Nextern _ARMABI char *tmpnam(char * /*s*/);
Xextern __declspec(__nothrow) char *tmpnam(char *  );
N   /*
N    * generates a string that is not the same as the name of an existing file.
N    * The tmpnam function generates a different string each time it is called,
N    * up to TMP_MAX times. If it is called more than TMP_MAX times, the
N    * behaviour is implementation-defined.
N    * Returns: If the argument is a null pointer, the tmpnam function leaves
N    *          its result in an internal static object and returns a pointer to
N    *          that object. Subsequent calls to the tmpnam function may modify
N    *          the same object. if the argument is not a null pointer, it is
N    *          assumed to point to an array of at least L_tmpnam characters;
N    *          the tmpnam function writes its result in that array and returns
N    *          the argument as its value.
N    */
N
Nextern _ARMABI int fclose(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fclose(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * causes the stream pointed to by stream to be flushed and the associated
N    * file to be closed. Any unwritten buffered data for the stream are
N    * delivered to the host environment to be written to the file; any unread
N    * buffered data are discarded. The stream is disassociated from the file.
N    * If the associated buffer was automatically allocated, it is deallocated.
N    * Returns: zero if the stream was succesfully closed, or nonzero if any
N    *          errors were detected or if the stream was already closed.
N    */
Nextern _ARMABI int fflush(FILE * /*stream*/);
Xextern __declspec(__nothrow) int fflush(FILE *  );
N   /*
N    * If the stream points to an output or update stream in which the most
N    * recent operation was output, the fflush function causes any unwritten
N    * data for that stream to be delivered to the host environment to be
N    * written to the file. If the stream points to an input or update stream,
N    * the fflush function undoes the effect of any preceding ungetc operation
N    * on the stream.
N    * Returns: nonzero if a write error occurs.
N    */
Nextern _ARMABI FILE *fopen(const char * __restrict /*filename*/,
Xextern __declspec(__nothrow) FILE *fopen(const char * __restrict  ,
N                           const char * __restrict /*mode*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * opens the file whose name is the string pointed to by filename, and
N    * associates a stream with it.
N    * The argument mode points to a string beginning with one of the following
N    * sequences:
N    * "r"         open text file for reading
N    * "w"         create text file for writing, or truncate to zero length
N    * "a"         append; open text file or create for writing at eof
N    * "rb"        open binary file for reading
N    * "wb"        create binary file for writing, or truncate to zero length
N    * "ab"        append; open binary file or create for writing at eof
N    * "r+"        open text file for update (reading and writing)
N    * "w+"        create text file for update, or truncate to zero length
N    * "a+"        append; open text file or create for update, writing at eof
N    * "r+b"/"rb+" open binary file for update (reading and writing)
N    * "w+b"/"wb+" create binary file for update, or truncate to zero length
N    * "a+b"/"ab+" append; open binary file or create for update, writing at eof
N    *
N    * Opening a file with read mode ('r' as the first character in the mode
N    * argument) fails if the file does not exist or cannot be read.
N    * Opening a file with append mode ('a' as the first character in the mode
N    * argument) causes all subsequent writes to be forced to the current end of
N    * file, regardless of intervening calls to the fseek function. In some
N    * implementations, opening a binary file with append mode ('b' as the
N    * second or third character in the mode argument) may initially position
N    * the file position indicator beyond the last data written, because of the
N    * NUL padding.
N    * When a file is opened with update mode ('+' as the second or third
N    * character in the mode argument), both input and output may be performed
N    * on the associated stream. However, output may not be directly followed
N    * by input without an intervening call to the fflush fuction or to a file
N    * positioning function (fseek, fsetpos, or rewind), and input be not be
N    * directly followed by output without an intervening call to the fflush
N    * fuction or to a file positioning function, unless the input operation
N    * encounters end-of-file. Opening a file with update mode may open or
N    * create a binary stream in some implementations. When opened, a stream
N    * is fully buffered if and only if it does not refer to an interactive
N    * device. The error and end-of-file indicators for the stream are
N    * cleared.
N    * Returns: a pointer to the object controlling the stream. If the open
N    *          operation fails, fopen returns a null pointer.
N    */
Nextern _ARMABI FILE *freopen(const char * __restrict /*filename*/,
Xextern __declspec(__nothrow) FILE *freopen(const char * __restrict  ,
N                    const char * __restrict /*mode*/,
N                    FILE * __restrict /*stream*/) __attribute__((__nonnull__(2,3)));
N   /*
N    * opens the file whose name is the string pointed to by filename and
N    * associates the stream pointed to by stream with it. The mode argument is
N    * used just as in the fopen function.
N    * The freopen function first attempts to close any file that is associated
N    * with the specified stream. Failure to close the file successfully is
N    * ignored. The error and end-of-file indicators for the stream are cleared.
N    * Returns: a null pointer if the operation fails. Otherwise, freopen
N    *          returns the value of the stream.
N    */
Nextern _ARMABI void setbuf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) void setbuf(FILE * __restrict  ,
N                    char * __restrict /*buf*/) __attribute__((__nonnull__(1)));
N   /*
N    * Except that it returns no value, the setbuf function is equivalent to the
N    * setvbuf function invoked with the values _IOFBF for mode and BUFSIZ for
N    * size, or (if buf is a null pointer), with the value _IONBF for mode.
N    * Returns: no value.
N    */
Nextern _ARMABI int setvbuf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int setvbuf(FILE * __restrict  ,
N                   char * __restrict /*buf*/,
N                   int /*mode*/, size_t /*size*/) __attribute__((__nonnull__(1)));
N   /*
N    * may be used after the stream pointed to by stream has been associated
N    * with an open file but before it is read or written. The argument mode
N    * determines how stream will be buffered, as follows: _IOFBF causes
N    * input/output to be fully buffered; _IOLBF causes output to be line
N    * buffered (the buffer will be flushed when a new-line character is
N    * written, when the buffer is full, or when input is requested); _IONBF
N    * causes input/output to be completely unbuffered. If buf is not the null
N    * pointer, the array it points to may be used instead of an automatically
N    * allocated buffer (the buffer must have a lifetime at least as great as
N    * the open stream, so the stream should be closed before a buffer that has
N    * automatic storage duration is deallocated upon block exit). The argument
N    * size specifies the size of the array. The contents of the array at any
N    * time are indeterminate.
N    * Returns: zero on success, or nonzero if an invalid value is given for
N    *          mode or size, or if the request cannot be honoured.
N    */
N#pragma __printf_args
Nextern _ARMABI int fprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int fprintf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * writes output to the stream pointed to by stream, under control of the
N    * string pointed to by format that specifies how subsequent arguments are
N    * converted for output. If there are insufficient arguments for the format,
N    * the behaviour is undefined. If the format is exhausted while arguments
N    * remain, the excess arguments are evaluated but otherwise ignored. The
N    * fprintf function returns when the end of the format string is reached.
N    * The format shall be a multibyte character sequence, beginning and ending
N    * in its initial shift state. The format is composed of zero or more
N    * directives: ordinary multibyte characters (not %), which are copied
N    * unchanged to the output stream; and conversion specifiers, each of which
N    * results in fetching zero or more subsequent arguments. Each conversion
N    * specification is introduced by the character %. For a description of the
N    * available conversion specifiers refer to section 4.9.6.1 in the ANSI
N    * draft mentioned at the start of this file or to any modern textbook on C.
N    * The minimum value for the maximum number of characters producable by any
N    * single conversion is at least 509.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
N#pragma __printf_args
Nextern _ARMABI int _fprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _fprintf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, but does not support floating-point formats.
N    * You can use instead of fprintf to improve code size.
N    * Returns: as fprintf.
N    */
N#pragma __printf_args
Nextern _ARMABI int printf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int printf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fprintf with the argument stdout interposed before the
N    * arguments to printf.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
N#pragma __printf_args
Nextern _ARMABI int _printf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _printf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to printf, but does not support floating-point formats.
N    * You can use instead of printf to improve code size.
N    * Returns: as printf.
N    */
N#pragma __printf_args
Nextern _ARMABI int sprintf(char * __restrict /*s*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int sprintf(char * __restrict  , const char * __restrict  , ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, except that the argument s specifies an array
N    * into which the generated output is to be written, rather than to a
N    * stream. A null character is written at the end of the characters written;
N    * it is not counted as part of the returned sum.
N    * Returns: the number of characters written to the array, not counting the
N    *          terminating null character.
N    */
N#pragma __printf_args
Nextern _ARMABI int _sprintf(char * __restrict /*s*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _sprintf(char * __restrict  , const char * __restrict  , ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sprintf, but does not support floating-point formats.
N    * You can use instead of sprintf to improve code size.
N    * Returns: as sprintf.
N    */
N
N#pragma __printf_args
Nextern _ARMABI int __ARM_snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int __ARM_snprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 199901L <= 199901L) || (0L && 201103L <= __cplusplus)
N#pragma __printf_args
Nextern _ARMABI int snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int snprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to fprintf, except that the argument s specifies an array
N    * into which the generated output is to be written, rather than to a
N    * stream. The argument n specifies the size of the output array, so as to
N    * avoid overflowing the buffer.
N    * A null character is written at the end of the characters written, even
N    * if the formatting was not completed; it is not counted as part of the
N    * returned sum. At most n characters of the output buffer are used,
N    * _including_ the null character.
N    * Returns: the number of characters that would have been written to the
N    *          array, not counting the terminating null character, if the
N    *          array had been big enough. So if the return is >=0 and <n, then
N    *          the entire string was successfully formatted; if the return is
N    *          >=n, the string was truncated (but there is still a null char
N    *          at the end of what was written); if the return is <0, there was
N    *          an error.
N    */
N#endif
N#pragma __printf_args
Nextern _ARMABI int _snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int _snprintf(char * __restrict  , size_t  ,
N                      const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to snprintf, but does not support floating-point formats.
N    * You can use instead of snprintf to improve code size.
N    * Returns: as snprintf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int fscanf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int fscanf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * reads input from the stream pointed to by stream, under control of the
N    * string pointed to by format that specifies the admissible input sequences
N    * and how thay are to be converted for assignment, using subsequent
N    * arguments as pointers to the objects to receive the converted input. If
N    * there are insufficient arguments for the format, the behaviour is
N    * undefined. If the format is exhausted while arguments remain, the excess
N    * arguments are evaluated but otherwise ignored.
N    * The format is composed of zero or more directives: one or more
N    * white-space characters; an ordinary character (not %); or a conversion
N    * specification. Each conversion specification is introduced by the
N    * character %. For a description of the available conversion specifiers
N    * refer to section 4.9.6.2 in the ANSI draft mentioned at the start of this
N    * file, or to any modern textbook on C.
N    * If end-of-file is encountered during input, conversion is terminated. If
N    * end-of-file occurs before any characters matching the current directive
N    * have been read (other than leading white space, where permitted),
N    * execution of the current directive terminates with an input failure;
N    * otherwise, unless execution of the current directive is terminated with a
N    * matching failure, execution of the following directive (if any) is
N    * terminated with an input failure.
N    * If conversions terminates on a conflicting input character, the offending
N    * input character is left unread in the input strem. Trailing white space
N    * (including new-line characters) is left unread unless matched by a
N    * directive. The success of literal matches and suppressed asignments is
N    * not directly determinable other than via the %n directive.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the fscanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early conflict between an input
N    *          character and the format.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _fscanf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _fscanf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fscanf, but does not support floating-point formats.
N    * You can use instead of fscanf to improve code size.
N    * Returns: as fscanf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int scanf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int scanf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fscanf with the argument stdin interposed before the
N    * arguments to scanf.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the scanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early matching failure.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _scanf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _scanf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to scanf, but does not support floating-point formats.
N    * You can use instead of scanf to improve code size.
N    * Returns: as scanf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int sscanf(const char * __restrict /*s*/,
Xextern __declspec(__nothrow) int sscanf(const char * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fscanf except that the argument s specifies a string
N    * from which the input is to be obtained, rather than from a stream.
N    * Reaching the end of the string is equivalent to encountering end-of-file
N    * for the fscanf function.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the scanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early matching failure.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _sscanf(const char * __restrict /*s*/,
Xextern __declspec(__nothrow) int _sscanf(const char * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sscanf, but does not support floating-point formats.
N    * You can use instead of sscanf to improve code size.
N    * Returns: as sscanf.
N    */
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 199901L <= 199901L) || (0L && 201103L <= __cplusplus)
N/* C99 additions */
Nextern _ARMABI int vfscanf(FILE * __restrict /*stream*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int vfscanf(FILE * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int vscanf(const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int vscanf(const char * __restrict  , __va_list) __attribute__((__nonnull__(1)));
Nextern _ARMABI int vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
N#endif
Nextern _ARMABI int _vfscanf(FILE * __restrict /*stream*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _vfscanf(FILE * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int _vscanf(const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _vscanf(const char * __restrict  , __va_list) __attribute__((__nonnull__(1)));
Nextern _ARMABI int _vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int __ARM_vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int __ARM_vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
N
Nextern _ARMABI int vprintf(const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int vprintf(const char * __restrict  , __va_list  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to printf, with the variable argument list replaced by arg,
N    * which has been initialised by the va_start macro (and possibly subsequent
N    * va_arg calls). The vprintf function does not invoke the va_end function.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
Nextern _ARMABI int _vprintf(const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _vprintf(const char * __restrict  , __va_list  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to vprintf, but does not support floating-point formats.
N    * You can use instead of vprintf to improve code size.
N    * Returns: as vprintf.
N    */
Nextern _ARMABI int vfprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int vfprintf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vfprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
Nextern _ARMABI int vsprintf(char * __restrict /*s*/,
Xextern __declspec(__nothrow) int vsprintf(char * __restrict  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vsprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters written in the array, not counting the
N    *          terminating null character.
N    */
Nextern _ARMABI int __ARM_vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int __ARM_vsnprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 199901L <= 199901L) || (0L && 201103L <= __cplusplus)
Nextern _ARMABI int vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int vsnprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to snprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vsprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters that would have been written in the
N    *          array, not counting the terminating null character. As
N    *          snprintf.
N    */
N#endif
Nextern _ARMABI int _vsprintf(char * __restrict /*s*/,
Xextern __declspec(__nothrow) int _vsprintf(char * __restrict  ,
N                      const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to vsprintf, but does not support floating-point formats.
N    * You can use instead of vsprintf to improve code size.
N    * Returns: as vsprintf.
N    */
Nextern _ARMABI int _vfprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _vfprintf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to vfprintf, but does not support floating-point formats.
N    * You can use instead of vfprintf to improve code size.
N    * Returns: as vfprintf.
N    */
Nextern _ARMABI int _vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int _vsnprintf(char * __restrict  , size_t  ,
N                      const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to vsnprintf, but does not support floating-point formats.
N    * You can use instead of vsnprintf to improve code size.
N    * Returns: as vsnprintf.
N    */
N#if !defined(__STRICT_ANSI__)
X#if !0L
N#pragma __printf_args
Nextern _ARMABI int asprintf(char ** /*strp*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int asprintf(char **  , const char * __restrict  , ...) __attribute__((__nonnull__(2)));
Nextern _ARMABI int vasprintf(char ** /*strp*/, const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int vasprintf(char **  , const char * __restrict  , __va_list  ) __attribute__((__nonnull__(2)));
N#endif
N#pragma __printf_args
Nextern _ARMABI int __ARM_asprintf(char ** /*strp*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int __ARM_asprintf(char **  , const char * __restrict  , ...) __attribute__((__nonnull__(2)));
Nextern _ARMABI int __ARM_vasprintf(char ** /*strp*/, const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int __ARM_vasprintf(char **  , const char * __restrict  , __va_list  ) __attribute__((__nonnull__(2)));
N   /*
N    * dynamically allocates a buffer of the right size for the
N    * formatted string, and returns it in (*strp). Formal return value
N    * is the same as any other printf variant, except that it returns
N    * -1 if the buffer could not be allocated.
N    *
N    * (The functions with __ARM_ prefixed names are identical to the
N    * ones without, but are available in all compilation modes without
N    * violating user namespace.)
N    */
N
Nextern _ARMABI int fgetc(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fgetc(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * obtains the next character (if present) as an unsigned char converted to
N    * an int, from the input stream pointed to by stream, and advances the
N    * associated file position indicator (if defined).
N    * Returns: the next character from the input stream pointed to by stream.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and fgetc returns EOF. If a read error occurs, the error
N    *          indicator is set and fgetc returns EOF.
N    */
Nextern _ARMABI char *fgets(char * __restrict /*s*/, int /*n*/,
Xextern __declspec(__nothrow) char *fgets(char * __restrict  , int  ,
N                    FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,3)));
N   /*
N    * reads at most one less than the number of characters specified by n from
N    * the stream pointed to by stream into the array pointed to by s. No
N    * additional characters are read after a new-line character (which is
N    * retained) or after end-of-file. A null character is written immediately
N    * after the last character read into the array.
N    * Returns: s if successful. If end-of-file is encountered and no characters
N    *          have been read into the array, the contents of the array remain
N    *          unchanged and a null pointer is returned. If a read error occurs
N    *          during the operation, the array contents are indeterminate and a
N    *          null pointer is returned.
N    */
Nextern _ARMABI int fputc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int fputc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * writes the character specified by c (converted to an unsigned char) to
N    * the output stream pointed to by stream, at the position indicated by the
N    * asociated file position indicator (if defined), and advances the
N    * indicator appropriately. If the file position indicator is not defined,
N    * the character is appended to the output stream.
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and fputc returns EOF.
N    */
Nextern _ARMABI int fputs(const char * __restrict /*s*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fputs(const char * __restrict  , FILE * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * writes the string pointed to by s to the stream pointed to by stream.
N    * The terminating null character is not written.
N    * Returns: EOF if a write error occurs; otherwise it returns a nonnegative
N    *          value.
N    */
Nextern _ARMABI int getc(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int getc(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fgetc except that it may be implemented as an unsafe
N    * macro (stream may be evaluated more than once, so the argument should
N    * never be an expression with side-effects).
N    * Returns: the next character from the input stream pointed to by stream.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and getc returns EOF. If a read error occurs, the error
N    *          indicator is set and getc returns EOF.
N    */
N#ifdef __cplusplus
S    inline int getchar() { return getc(stdin); }
N#else
N    #define getchar() getc(stdin)
N    extern _ARMABI int (getchar)(void);
X    extern __declspec(__nothrow) int (getchar)(void);
N#endif
N   /*
N    * is equivalent to getc with the argument stdin.
N    * Returns: the next character from the input stream pointed to by stdin.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and getchar returns EOF. If a read error occurs, the error
N    *          indicator is set and getchar returns EOF.
N    */
Nextern _ARMABI char *gets(char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *gets(char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * reads characters from the input stream pointed to by stdin into the array
N    * pointed to by s, until end-of-file is encountered or a new-line character
N    * is read. Any new-line character is discarded, and a null character is
N    * written immediately after the last character read into the array.
N    * Returns: s if successful. If end-of-file is encountered and no characters
N    *          have been read into the array, the contents of the array remain
N    *          unchanged and a null pointer is returned. If a read error occurs
N    *          during the operation, the array contents are indeterminate and a
N    *          null pointer is returned.
N    */
Nextern _ARMABI int putc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int putc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * is equivalent to fputc except that it may be implemented as aan unsafe
N    * macro (stream may be evaluated more than once, so the argument should
N    * never be an expression with side-effects).
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and putc returns EOF.
N    */
N#ifdef __cplusplus
S    inline int putchar(int __c) { return putc(__c, stdout); }
N#else
N    #define putchar(c) putc(c, stdout)
N    extern _ARMABI int (putchar)(int /*c*/);
X    extern __declspec(__nothrow) int (putchar)(int  );
N#endif
N   /*
N    * is equivalent to putc with the second argument stdout.
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and putc returns EOF.
N    */
Nextern _ARMABI int puts(const char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int puts(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * writes the string pointed to by s to the stream pointed to by stdout, and
N    * appends a new-line character to the output. The terminating null
N    * character is not written.
N    * Returns: EOF if a write error occurs; otherwise it returns a nonnegative
N    *          value.
N    */
Nextern _ARMABI int ungetc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int ungetc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * pushes the character specified by c (converted to an unsigned char) back
N    * onto the input stream pointed to by stream. The character will be
N    * returned by the next read on that stream. An intervening call to the
N    * fflush function or to a file positioning function (fseek, fsetpos,
N    * rewind) discards any pushed-back characters. The extern _ARMABIal storage
N    * corresponding to the stream is unchanged.
N    * One character pushback is guaranteed. If the unget function is called too
N    * many times on the same stream without an intervening read or file
N    * positioning operation on that stream, the operation may fail.
N    * If the value of c equals that of the macro EOF, the operation fails and
N    * the input stream is unchanged.
N    * A successful call to the ungetc function clears the end-of-file
N    * indicator. The value of the file position indicator after reading or
N    * discarding all pushed-back characters shall be the same as it was before
N    * the characters were pushed back. For a text stream, the value of the file
N    * position indicator after a successful call to the ungetc function is
N    * unspecified until all pushed-back characters are read or discarded. For a
N    * binary stream, the file position indicator is decremented by each
N    * successful call to the ungetc function; if its value was zero before a
N    * call, it is indeterminate after the call.
N    * Returns: the character pushed back after conversion, or EOF if the
N    *          operation fails.
N    */
N
Nextern _ARMABI size_t fread(void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t fread(void * __restrict  ,
N                    size_t /*size*/, size_t /*nmemb*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,4)));
N   /*
N    * reads into the array pointed to by ptr, up to nmemb members whose size is
N    * specified by size, from the stream pointed to by stream. The file
N    * position indicator (if defined) is advanced by the number of characters
N    * successfully read. If an error occurs, the resulting value of the file
N    * position indicator is indeterminate. If a partial member is read, its
N    * value is indeterminate. The ferror or feof function shall be used to
N    * distinguish between a read error and end-of-file.
N    * Returns: the number of members successfully read, which may be less than
N    *          nmemb if a read error or end-of-file is encountered. If size or
N    *          nmemb is zero, fread returns zero and the contents of the array
N    *          and the state of the stream remain unchanged.
N    */
N
Nextern _ARMABI size_t __fread_bytes_avail(void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t __fread_bytes_avail(void * __restrict  ,
N                    size_t /*count*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,3)));
N   /*
N    * reads into the array pointed to by ptr, up to count characters from the
N    * stream pointed to by stream. The file position indicator (if defined)
N    * is advanced by the number of characters successfully read. If an error
N    * occurs, the resulting value of the file position indicator is
N    * indeterminate. The ferror or feof function shall be used to
N    * distinguish between a read error and end-of-file.  The call will block
N    * only if no characters are available.
N    * Returns: the number of characters successfully read, which may be less than
N    *          count. If count is zero, __fread_bytes_avail returns zero and
N    *          the contents of the array and the state of the stream remain
N    *          unchanged.
N    */
N
Nextern _ARMABI size_t fwrite(const void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t fwrite(const void * __restrict  ,
N                    size_t /*size*/, size_t /*nmemb*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,4)));
N   /*
N    * writes, from the array pointed to by ptr up to nmemb members whose size
N    * is specified by size, to the stream pointed to by stream. The file
N    * position indicator (if defined) is advanced by the number of characters
N    * successfully written. If an error occurs, the resulting value of the file
N    * position indicator is indeterminate.
N    * Returns: the number of members successfully written, which will be less
N    *          than nmemb only if a write error is encountered.
N    */
N
Nextern _ARMABI int fgetpos(FILE * __restrict /*stream*/, fpos_t * __restrict /*pos*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fgetpos(FILE * __restrict  , fpos_t * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * stores the current value of the file position indicator for the stream
N    * pointed to by stream in the object pointed to by pos. The value stored
N    * contains unspecified information usable by the fsetpos function for
N    * repositioning the stream to its position at the time  of the call to the
N    * fgetpos function.
N    * Returns: zero, if successful. Otherwise nonzero is returned and the
N    *          integer expression errno is set to an implementation-defined
N    *          nonzero value.
N    */
Nextern _ARMABI int fseek(FILE * /*stream*/, long int /*offset*/, int /*whence*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fseek(FILE *  , long int  , int  ) __attribute__((__nonnull__(1)));
N   /*
N    * sets the file position indicator for the stream pointed to by stream.
N    * For a binary stream, the new position is at the signed number of
N    * characters specified by offset away from the point specified by whence.
N    * The specified point is the beginning of the file for SEEK_SET, the
N    * current position in the file for SEEK_CUR, or end-of-file for SEEK_END.
N    * A binary stream need not meaningfully support fseek calls with a whence
N    * value of SEEK_END.
N    * For a text stream, either offset shall be zero, or offset shall be a
N    * value returned by an earlier call to the ftell function on the same
N    * stream and whence shall be SEEK_SET.
N    * The fseek function clears the end-of-file indicator and undoes any
N    * effects of the ungetc function on the same stream. After an fseek call,
N    * the next operation on an update stream may be either input or output.
N    * Returns: nonzero only for a request that cannot be satisfied.
N    */
Nextern _ARMABI int fsetpos(FILE * __restrict /*stream*/, const fpos_t * __restrict /*pos*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fsetpos(FILE * __restrict  , const fpos_t * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * sets  the file position indicator for the stream pointed to by stream
N    * according to the value of the object pointed to by pos, which shall be a
N    * value returned by an earlier call to the fgetpos function on the same
N    * stream.
N    * The fsetpos function clears the end-of-file indicator and undoes any
N    * effects of the ungetc function on the same stream. After an fsetpos call,
N    * the next operation on an update stream may be either input or output.
N    * Returns: zero, if successful. Otherwise nonzero is returned and the
N    *          integer expression errno is set to an implementation-defined
N    *          nonzero value.
N    */
Nextern _ARMABI long int ftell(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long int ftell(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * obtains the current value of the file position indicator for the stream
N    * pointed to by stream. For a binary stream, the value is the number of
N    * characters from the beginning of the file. For a text stream, the file
N    * position indicator contains unspecified information, usable by the fseek
N    * function for returning the file position indicator to its position at the
N    * time of the ftell call; the difference between two such return values is
N    * not necessarily a meaningful measure of the number of characters written
N    * or read.
N    * Returns: if successful, the current value of the file position indicator.
N    *          On failure, the ftell function returns -1L and sets the integer
N    *          expression errno to an implementation-defined nonzero value.
N    */
Nextern _ARMABI void rewind(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void rewind(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * sets the file position indicator for the stream pointed to by stream to
N    * the beginning of the file. It is equivalent to
N    *          (void)fseek(stream, 0L, SEEK_SET)
N    * except that the error indicator for the stream is also cleared.
N    * Returns: no value.
N    */
N
Nextern _ARMABI void clearerr(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void clearerr(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * clears the end-of-file and error indicators for the stream pointed to by
N    * stream. These indicators are cleared only when the file is opened or by
N    * an explicit call to the clearerr function or to the rewind function.
N    * Returns: no value.
N    */
N
Nextern _ARMABI int feof(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int feof(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * tests the end-of-file indicator for the stream pointed to by stream.
N    * Returns: nonzero iff the end-of-file indicator is set for stream.
N    */
Nextern _ARMABI int ferror(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int ferror(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * tests the error indicator for the stream pointed to by stream.
N    * Returns: nonzero iff the error indicator is set for stream.
N    */
Nextern _ARMABI void perror(const char * /*s*/);
Xextern __declspec(__nothrow) void perror(const char *  );
N   /*
N    * maps the error number  in the integer expression errno to an error
N    * message. It writes a sequence of characters to the standard error stream
N    * thus: first (if s is not a null pointer and the character pointed to by
N    * s is not the null character), the string pointed to by s followed by a
N    * colon and a space; then an appropriate error message string followed by
N    * a new-line character. The contents of the error message strings are the
N    * same as those returned by the strerror function with argument errno,
N    * which are implementation-defined.
N    * Returns: no value.
N    */
N
Nextern _ARMABI int _fisatty(FILE * /*stream*/ ) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _fisatty(FILE *   ) __attribute__((__nonnull__(1)));
N    /* Returns 1 if the stream is tty (stdin), 0 otherwise. Not ANSI compliant.
N     */
N
Nextern _ARMABI void __use_no_semihosting_swi(void);
Xextern __declspec(__nothrow) void __use_no_semihosting_swi(void);
Nextern _ARMABI void __use_no_semihosting(void);
Xextern __declspec(__nothrow) void __use_no_semihosting(void);
N    /*
N     * Referencing either of these symbols will cause a link-time
N     * error if any library functions that use semihosting SWI
N     * calls are also present in the link, i.e. you define it if
N     * you want to make sure you haven't accidentally used any such
N     * SWIs.
N     */
N
N    #ifdef __cplusplus
S        }  /* extern "C" */
S      }  /* namespace std */
N    #endif
N  #endif /* __STDIO_DECLS */
N
N  #if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X  #if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S    #define _AEABI_PORTABLE
N  #endif
N
N  #if defined(__cplusplus) && !defined(__STDIO_NO_EXPORTS)
X  #if 0L && !0L
S    using ::std::size_t;
S    using ::std::fpos_t;
S    using ::std::FILE;
S    using ::std::remove;
S    using ::std::rename;
S    using ::std::tmpfile;
S    using ::std::tmpnam;
S    using ::std::fclose;
S    using ::std::fflush;
S    using ::std::fopen;
S    using ::std::freopen;
S    using ::std::setbuf;
S    using ::std::setvbuf;
S    using ::std::fprintf;
S    using ::std::_fprintf;
S    using ::std::printf;
S    using ::std::_printf;
S    using ::std::sprintf;
S    using ::std::_sprintf;
S    #if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
S      using ::std::snprintf;
S      using ::std::vsnprintf;
S      using ::std::vfscanf;
S      using ::std::vscanf;
S      using ::std::vsscanf;
S    #endif
S    using ::std::_snprintf;
S    using ::std::_vsnprintf;
S#if !defined(__STRICT_ANSI__)
S    using ::std::asprintf;
S    using ::std::vasprintf;
S#endif
S    using ::std::__ARM_asprintf;
S    using ::std::__ARM_vasprintf;
S    using ::std::__ARM_vsnprintf;
S    using ::std::__ARM_snprintf;
S    using ::std::__ARM_vsscanf;
S    using ::std::fscanf;
S    using ::std::_fscanf;
S    using ::std::scanf;
S    using ::std::_scanf;
S    using ::std::sscanf;
S    using ::std::_sscanf;
S    using ::std::_vfscanf;
S    using ::std::_vscanf;
S    using ::std::_vsscanf;
S    using ::std::vprintf;
S    using ::std::_vprintf;
S    using ::std::vfprintf;
S    using ::std::_vfprintf;
S    using ::std::vsprintf;
S    using ::std::_vsprintf;
S    using ::std::fgetc;
S    using ::std::fgets;
S    using ::std::fputc;
S    using ::std::fputs;
S    using ::std::getc;
S    using ::std::getchar;
S    using ::std::gets;
S    using ::std::putc;
S    using ::std::putchar;
S    using ::std::puts;
S    using ::std::ungetc;
S    using ::std::fread;
S    using ::std::__fread_bytes_avail;
S    using ::std::fwrite;
S    using ::std::fgetpos;
S    using ::std::fseek;
S    using ::std::fsetpos;
S    using ::std::ftell;
S    using ::std::rewind;
S    using ::std::clearerr;
S    using ::std::feof;
S    using ::std::ferror;
S    using ::std::perror;
S    using ::std::_fisatty;
S    using ::std::__use_no_semihosting_swi;
S    using ::std::__use_no_semihosting;
N  #endif
N
N#endif /* ndef __stdio_h */
N
N/* end of stdio.h */
N
L 13 "app\bim_uart.c" 2
N#include "bim_app.h"
L 1 "app\bim_app.h" 1
N#ifndef _BIM_APP_H_
N#define _BIM_APP_H_
N
N#include <stdint.h>
N
Nenum
N{
N	ICU_CLK_16M,
N       ICU_CLK_32M,
N	ICU_CLK_64M,
N
N};
N
Nvoid bim_icu_init(uint8_t clk);
N
N#endif
L 14 "app\bim_uart.c" 2
N#include "bim_flash.h"
L 1 "app\bim_flash.h" 1
N
N#ifndef _BIM_FLASH_H_
N#define _BIM_FLASH_H_
N
N#include <stdint.h>
N#include "BK3432_reg.h"
N
N
Nenum 
N{
N	FLASH_SPACE_TYPE_MAIN = 0x00,
N	FLASH_SPACE_TYPE_NVR = 0x01,
N	FLASH_SPACE_TYPE_INVALID = 0XFF,
N};
N
N
N#define FLASH_TYPE_EMBEN        FLASH_SPACE_TYPE_NVR
N#define FLASH_MAIN_SIZE              0x00028000
N#define FLASH_NVR_SIZE               0x00000200
N#define FLASH_WRITE_ECC_DATA0 0XA3
N#define FLASH_WRITE_ECC_DATA1 0X56
N
N
Nvoid bim_flash_init(void);
Nvoid bim_flash_erase_sector(uint8_t type,uint32_t address);
Nvoid bim_flash_erase(uint8_t flash_type, uint32_t address, uint32_t size);
Nvoid bim_flash_read(uint8_t flash_space, uint32_t address, uint32_t length, uint8_t * buffer);
Nvoid bim_flash_write(uint8_t flash_space, uint32_t address, uint32_t length, uint8_t * buffer);
Nvoid bim_wdt_enable(uint16_t wdt_cnt);
Nvoid bim_wdt_disable(void);
N
N#endif
N
N
N
N
N
L 15 "app\bim_uart.c" 2
N
N
N
N
N
N
N#define Uart_Write_Byte(v)               (REG_APB3_UART_PORT=v)
N#define UART_TX_FIFO_COUNT               (REG_APB3_UART_FIFO_STAT&0xff)
N#define UART_RX_FIFO_COUNT               ((REG_APB3_UART_FIFO_STAT>>8)&0xff)
N#define UART_TX_FIFO_FULL                (REG_APB3_UART_FIFO_STAT&0x00010000)
N#define UART_TX_FIFO_EMPTY               (REG_APB3_UART_FIFO_STAT&0x00020000)
N#define UART_RX_FIFO_FULL                (REG_APB3_UART_FIFO_STAT&0x00040000)
N#define UART_RX_FIFO_EMPTY               (REG_APB3_UART_FIFO_STAT&0x00080000)
N#define UART_TX_WRITE_READY              (REG_APB3_UART_FIFO_STAT&0x00100000)
N#define UART_RX_READ_READY               (REG_APB3_UART_FIFO_STAT&0x00200000)
N#define bit_UART_TXFIFO_NEED_WRITE        0x01
N#define bit_UART_RXFIFO_NEED_READ         0x02
N#define bit_UART_RXFIFO_OVER_FLOW         0x04
N#define bit_UART_RX_PARITY_ERROR          0x08
N#define bit_UART_RX_STOP_ERROR            0x10
N#define bit_UART_TX_PACKET_END            0x20
N#define bit_UART_RX_PACKET_END            0x40
N#define bit_UART_RXD_WAKEUP_DETECT        0x80
N
N
N
N
N#define uart_tx_en    0x1      // 0: Disable TX, 1: Enable TX 
N#define uart_rx_en    0x1      // 0: Disable RX, 1: Enable RX
N#define irda_mode     0x0      // 0: UART  MODE, 1: IRDA MODE
N#define data_len      0x3      // 0: 5 bits, 1: 6 bits, 2: 7 bits, 3: 8 bits
N#define parity_en     0x1      // 0: NO Parity, 1: Enable Parity
N#define parity_mode   0x1      // 0: Odd Check, 1: Even Check 
N#define stop_bits     0x0      // 0: 1 stop-bit, 1: 2 stop-bit 
N#define uart_clks     16000000 // UART's Main-Freq, 26M 
N#define baud_rate     115200 // UART's Baud-Rate,  1M 
N#define BIM_REG_PL_RD(addr)              (*(volatile uint32_t *)(addr))
N
Nint bim_uart_printf_null(const char *fmt,...)
N{
N	return 0;
N}
N
N#if 0
Sint bim_uart_printf(const char *fmt,...)
S{
S	return 0;
S}
S
Sint bim_uart_putchar(char * st)
S{
S	uint8_t num = 0;
S
S	while (*st)
S	{
S		if(UART_TX_WRITE_READY)
S		{
S			REG_APB3_UART_PORT = *st;
S			st++;
S			num++;
S		}
S	}
S
S	return num;
S}
N#endif
Nvoid uart_send(unsigned char *buff, int len)
N{
N	while (len--)
N	{
N		while(!UART_TX_WRITE_READY);
X		while(!((*((volatile unsigned long *) 0x00806308))&0x00100000));
N		REG_APB3_UART_PORT = *buff++ ;
X		(*((volatile unsigned long *) 0x0080630C)) = *buff++ ;
N	}
N}
N#if 0
Suint8_t bim_uart_fifo_empty_getf(void)
S{
S	uint32_t localVal = BIM_REG_PL_RD(0x00806308);
S	return ((localVal & ((uint32_t)0x00020000)) >> 17);
S}
S
Svoid bim_uart_send_byte( char data)
S{
S	while (!bim_uart_fifo_empty_getf());
S
S	REG_APB3_UART_PORT = data ;
S}
N#endif
Nvoid bim_uart_write( char *buff)
N{
N#if 0
S	uint8_t len = strlen((char*)buff);
S	while (len--)
S		bim_uart_send_byte(*buff++);
N#endif
N}
N
N
N
N
Nvoid bim_printf(char *title, uint32_t v, uint8_t radix)
N{
N#if 0
S	uint8_t	tmpLen;
S	char buf[128];
S	uint32_t err;
S
S	tmpLen = strlen( (char*)title);
S	memcpy( buf, title, tmpLen );
S	err = (uint32_t)(v);
S	itoa_my( err, &buf[tmpLen], radix);
S	bim_uart_write(&buf[0]);
N#endif
N}
N
N
Nvoid bim_uart_init(uint32_t baudrate)
N{
N
N	unsigned int baud_divisor ;
N	REG_AHB0_ICU_UARTCLKCON   &= ~(0x1 << 0) ;  // Enable Uart's Clocks
X	(*((volatile unsigned long *) 0x0080000c))   &= ~(0x1 << 0) ;  
N	baud_divisor = 0x8a;//uart_clks/baud_rate ;
N	baud_divisor = baud_divisor-1 ;
N	REG_APB3_UART_CFG  = (baud_divisor<<8) +
X	(*((volatile unsigned long *) 0x00806300))  = (baud_divisor<<8) +
N	                     (stop_bits   <<7) +
X	                     (0x0   <<7) +
N	                     //(parity_mode <<6) +
N	                     //(parity_en   <<5) +
N	                     (data_len    <<3) +
X	                     (0x3    <<3) +
N	                     (irda_mode   <<2) +
X	                     (0x0   <<2) +
N	                     (uart_rx_en  <<1) +
X	                     (0x1  <<1) +
N	                     uart_tx_en       ;
X	                     0x1       ;
N	REG_APB3_UART_FIFO_CFG  = 0x00001001 ;  // Set Fifo threshold 8
X	(*((volatile unsigned long *) 0x00806304))  = 0x00001001 ;  
N	REG_APB3_UART_INT_ENABLE = ((0x01 << 1) | (0x01 << 6) | (0x01 << 7));  //need read / stop end /rxd wake up
X	(*((volatile unsigned long *) 0x00806310)) = ((0x01 << 1) | (0x01 << 6) | (0x01 << 7));  
N	REG_APB3_UART_FLOW_CFG  = 0x00000000 ;  // No Flow Control
X	(*((volatile unsigned long *) 0x00806318))  = 0x00000000 ;  
N	REG_APB3_UART_WAKE_CFG  =  ((0x01 << 0 )| (0x01 << 20) |  (0x01 << 21)| (0x01 << 22));  // No Wake Control
X	(*((volatile unsigned long *) 0x0080631c))  =  ((0x01 << 0 )| (0x01 << 20) |  (0x01 << 21)| (0x01 << 22));  
N
N	REG_APB5_GPIOA_CFG  &= ~((0x3<<BIT_GPIO_PULL_UP)  + (0x3<<BIT_GPIO_PERI_EN));
X	(*((volatile unsigned long *) 0x00806500))  &= ~((0x3<<16)  + (0x3<<0));
N	REG_APB5_GPIOA_CFG  |= ((0x3<<BIT_GPIO_PULL_UP));
X	(*((volatile unsigned long *) 0x00806500))  |= ((0x3<<16));
N	REG_APB5_GPIOA_CFG  |=   (0x3<<BIT_GPIO_OUT_EN_N);
X	(*((volatile unsigned long *) 0x00806500))  |=   (0x3<<8);
N
N	REG_APB5_GPIOA_DATA &= ~ (0x3<<BIT_GPIO_INPUT_EN);
X	(*((volatile unsigned long *) 0x00806504)) &= ~ (0x3<<16);
N
N}
N
N
N
N#if 1 //
Nvoid bim_uart_deinit( void )
N{
N	REG_AHB0_ICU_UARTCLKCON   = 0x1 ;  // disable Uart's Clocks
X	(*((volatile unsigned long *) 0x0080000c))   = 0x1 ;  
N
N	REG_APB5_GPIOA_CFG  &= ~((0x3<<BIT_GPIO_PULL_UP)  + (0x3<<BIT_GPIO_PERI_EN));
X	(*((volatile unsigned long *) 0x00806500))  &= ~((0x3<<16)  + (0x3<<0));
N	REG_APB5_GPIOA_CFG  |= ((0x3<<BIT_GPIO_PERI_EN));
X	(*((volatile unsigned long *) 0x00806500))  |= ((0x3<<0));
N
N}
N
N
Nuint8_t erase_fenable;
Nuint8_t bim_uart_rx_buf[BIM_UART0_RX_FIFO_MAX_COUNT];
Xuint8_t bim_uart_rx_buf[8196];
Nuint8_t bim_uart_cmd[16];
Nuint8_t bim_uart_data[4096+8];
N//uint8_t read_data[512];
Nuint8_t uart_download_status=0;
Nuint16_t uart_buff_write;
N
Nvoid bim_uart_isr(void)
N{
N	unsigned int IntStat;
N
N	IntStat = REG_APB3_UART_INT_STAT;
X	IntStat = (*((volatile unsigned long *) 0x00806314));
N	if(IntStat & 0x42)
N	{
N		while((REG_APB3_UART_FIFO_STAT & (0x01 << 21)))
X		while(((*((volatile unsigned long *) 0x00806308)) & (0x01 << 21)))
N		{
N			bim_uart_rx_buf[uart_buff_write++] = ((REG_APB3_UART_PORT>>8)&0xff);
X			bim_uart_rx_buf[uart_buff_write++] = (((*((volatile unsigned long *) 0x0080630C))>>8)&0xff);
N			if( BIM_UART0_RX_FIFO_MAX_COUNT == uart_buff_write )
X			if( 8196 == uart_buff_write )
N			{
N				uart_buff_write = 0;
N			}
N		}
N
N	}
N	REG_APB3_UART_INT_STAT=IntStat;
X	(*((volatile unsigned long *) 0x00806314))=IntStat;
N}
N
N
Nvoid bim_uart_data_callback( uint8_t * buff, uint16_t len)
N{
N	static uint8_t cmd_status=0;
N	static uint16_t index=0,index_cnt=0;
N
N	static uint16_t length;
N	static uint16_t scmd_length;
N	static uint32_t write_addr;
N	static uint32_t read_addr;
N	static uint8_t read_buff[256];
N
N
N	while(len>0)
N	{
N		switch(cmd_status)
N		{
N
N		case UART_CMD_STATE_HEAD:
N		{
N			if(buff[0]==0x01)
N			{
N				cmd_status=UART_CMD_STATE_OPCODE_ONE;
N			}
N			else
N				cmd_status=UART_CMD_STATE_HEAD;
N		}
N		break;
N		case UART_CMD_STATE_OPCODE_ONE:
N		{
N			if( buff[0]==0xe0 )
N				cmd_status=UART_CMD_STATE_OPCODE_TWO;
N			else
N				cmd_status=UART_CMD_STATE_HEAD;
N
N
N		}
N		break;
N		case UART_CMD_STATE_OPCODE_TWO:
N		{
N			if( buff[0]==0xfc )
N				cmd_status=UART_CMD_STATE_LENGTH;
N			else
N				cmd_status=UART_CMD_STATE_HEAD;
N		}
N		break;
N		case UART_CMD_STATE_LENGTH:
N		{
N			length=buff[0];
N
N			if(0xff==buff[0])
N			{
N				cmd_status=UART_CMD_STATE_CMD_FLASH;
N			}
N			else if( buff[0]>0 && buff[0]!=0xff )
N			{
N				cmd_status=UART_CMD_STATE_CMD;
N				index=0;
N			}
N			else
N				cmd_status=UART_CMD_STATE_HEAD;
N
N
N		}
N		break;
N
N		case UART_CMD_STATE_CMD:
N		{
N			bim_uart_cmd[index++]=buff[0];
N
N			if(index==length)
N			{
N
N				uart_cmd_dispath(bim_uart_cmd, length);
N				cmd_status=UART_CMD_STATE_HEAD;
N			}
N		}
N		break;
N
N		case UART_CMD_STATE_CMD_FLASH:
N		{
N			if( buff[0]==0xf4 )
N				cmd_status=UART_CMD_STATE_LENGTH_FLASH_LEN0;
N			else
N				cmd_status=UART_CMD_STATE_HEAD;
N		}
N		break;
N		case UART_CMD_STATE_LENGTH_FLASH_LEN0:
N		{
N			cmd_status=UART_CMD_STATE_LENGTH_FLASH_LEN1;
N			scmd_length=buff[0];
N
N		}
N		break;
N		case UART_CMD_STATE_LENGTH_FLASH_LEN1:
N		{
N
N			scmd_length += (buff[0]<<8);
N
N			if(scmd_length>0)
N				cmd_status=UART_CMD_STATE_LENGTH_FLASH_SCMD;
N			else
N				cmd_status=UART_CMD_STATE_HEAD;
N
N			index=0;
N			index_cnt=0;
N		}
N		break;
N
N		case UART_CMD_STATE_LENGTH_FLASH_SCMD:
N		{
N			bim_uart_data[index++]=buff[0];
N
N			/*
N			 if(bim_uart_data[0]==0x0a && index==scmd_length )
N			 {
N			     int32_t addr = SEC_IMAGE_ALLOC_END_FADDR ;
N
N			     bim_fflash_wr_protect_8k();
N				bim_fflash_erase_one_block(addr);
N
N				addr -= FLASH_ONE_BLOCK_SIZE;
N				bim_fflash_erase_one_block(addr);
N
N				addr -= FLASH_ONE_BLOCK_SIZE;
N				bim_fflash_erase_one_block(addr);
N
N			     addr -= FLASH_ONE_BLOCK_SIZE;
N				bim_fflash_erase_one_block(addr);
N
N				addr -= FLASH_SEC_SIZE;
N				for(;addr >= SEC_IMAGE_ALLOC_START_STACK_FADDR;addr-= FLASH_SEC_SIZE )
N				{
N					bim_erase_section(addr,FLASH_SEC_SIZE);
N				}
N
N			     operate_flash_cmd_response(0x0a,0,3,&bim_uart_data[1]);
N			     cmd_status=UART_CMD_STATE_HEAD;
N			 }*/
N
N
N
N			if(bim_uart_data[0]==0x09 && index==scmd_length)//read id
N			{
N				read_addr = bim_uart_data[1]|(bim_uart_data[2]<<8)|(bim_uart_data[3]<<16)|(bim_uart_data[4]<<24) ;
N
N				if(read_addr<0x27ff0)
N				{
N					bim_uart_data[5]=scmd_length-5;
N					operate_flash_cmd_response(0x09,6,7,&bim_uart_data[1]);
N				}
N				else
N				{
N					bim_flash_read(FLASH_SPACE_TYPE_MAIN, read_addr/4, 16, read_buff);
N					for(uint8_t i=0; i<16; i++)
N						bim_uart_data[5+i]=read_buff[i];
N
N					operate_flash_cmd_response(0x09,0,4102,&bim_uart_data[1]);
N
N				}
N				cmd_status=UART_CMD_STATE_HEAD;
N
N			}
N			else if(bim_uart_data[0]==0x0f && index==scmd_length)//erase
N			{
N				int32_t addr = bim_uart_data[2]|(bim_uart_data[3]<<8)|(bim_uart_data[4]<<16)|(bim_uart_data[5]<<24) ;
N
N				if(addr<0x1000)
N				{
N					operate_flash_cmd_response(0x0f,6,0x07,&bim_uart_data[1]);
N				}
N				else
N				{
N					if(erase_fenable==1)
N					{
N						//if(addr>=0x20000)
N						// 128k
N						//bim_fflash_wr_protect_128k();
N						//else
N						// 32k
N						//bim_fflash_wr_protect_8k();
N						erase_fenable=0;
N					}
N
N
N					if(bim_uart_data[1]==0x20)
N					{
N						//bim_erase_section(addr,FLASH_SEC_SIZE);
N						bim_flash_erase(FLASH_SPACE_TYPE_MAIN, addr/4, 1024);
N
N					}
N					else if(bim_uart_data[1]==0xd8)
N					{
N						//bim_fflash_erase_one_block(addr);
N						bim_flash_erase(FLASH_SPACE_TYPE_MAIN, addr/4, 8*1024);
N
N					}
N					operate_flash_cmd_response(0x0f,0,0x07,&bim_uart_data[1]);
N				}
N				cmd_status=UART_CMD_STATE_HEAD;
N			}
N			else if(bim_uart_data[0]==0x06 && index==scmd_length)//write bt addr
N			{
N				write_addr = bim_uart_data[1]|(bim_uart_data[2]<<8)|(bim_uart_data[3]<<16)|(bim_uart_data[4]<<24) ;
N
N				if(write_addr<0x27ff0)
N				{
N					bim_uart_data[5]=scmd_length-5;
N					operate_flash_cmd_response(0x06,6,7,&bim_uart_data[1]);
N				}
N				else
N				{
N					bim_flash_write(FLASH_SPACE_TYPE_MAIN, write_addr/4, (scmd_length-5), &bim_uart_data[5]);
N					bim_uart_data[5]=scmd_length-5;
N					operate_flash_cmd_response(0x06,0,7,&bim_uart_data[1]);
N
N				}
N				cmd_status=UART_CMD_STATE_HEAD;
N
N			}
N			else if( bim_uart_data[0]==0x07 )//write code data
N			{
N
N				if(index >= (256*(index_cnt+1)+5) )
N				{
N					write_addr = bim_uart_data[1]|(bim_uart_data[2]<<8)|(bim_uart_data[3]<<16)|(bim_uart_data[4]<<24) ;
N
N
N					if(write_addr<0x1000)
N					{
N
N						index_cnt++;
N						if(index==scmd_length )
N						{
N							bim_uart_data[1]=0xf0;
N							bim_uart_data[2]=0x1f;
N							operate_flash_cmd_response(0x07,6,6,&bim_uart_data[1]);
N							cmd_status=UART_CMD_STATE_HEAD;
N							index_cnt=0;
N						}
N					}
N					else
N					{
N						bim_flash_write(FLASH_SPACE_TYPE_MAIN, (write_addr+256*(index_cnt))/4, 256, &bim_uart_data[5+256*(index_cnt)]);
N
N						index_cnt++;
N
N						if(index==scmd_length )
N						{
N							operate_flash_cmd_response(0x07,0,6,&bim_uart_data[1]);
N							cmd_status=UART_CMD_STATE_HEAD;
N							index_cnt=0;
N						}
N					}
N				}
N			}
N			else if(index==scmd_length)
N				cmd_status=UART_CMD_STATE_HEAD;
N		}
N		break;
N
N		}
N		len--;
N		buff++;
N	}
N}
N
N
Nuint32_t crc32_table[256];
Nint make_crc32_table(void)
N{
N	uint32_t c;
N	int i = 0;
N	int bit = 0;
N	for(i = 0; i < 256; i++)
N	{
N		c = (uint32_t)i;
N		for(bit = 0; bit < 8; bit++)
N		{
N			if(c&1)
N			{
N				c = (c>>1)^(0xEDB88320);
N			}
N			else
N			{
N				c = c >> 1;
N			}
N		}
N		crc32_table[i] = c;
N
N	}
N	return 0;
N}
N
Nuint32_t make_crc32(uint32_t crc,unsigned char *string,uint32_t size)
N{
N	while(size--)
N	{
N		crc = (crc >> 8)^(crc32_table[(crc^*string++)&0xff]);
N	}
N	return crc;
N}
N
Nvoid bim_delay_ms(unsigned int tt)
N{
N	volatile unsigned int i, j;
N	while(tt--)
N	{
N		for (j = 0; j < 1000/10; j++)
N		{
N			for (i = 0; i < 12; i++)
N			{
N				;
N			}
N		}
N	}
N}
N
N
N
Nvoid uart_cmd_dispath(uint8_t *buff,uint8_t len)
N{
N	uint8_t payload[16];
N	uint8_t read_data[256];
N	uint32_t  calcuCrc=0xffffffff;
N
N	uint32_t read_flash_addr;
N	uint32_t uart_clk_div,baudrate_set;
N	uint32_t crc_start_addr,crc_end_addr;
N
N
N	switch(buff[0])
N	{
N	case LINK_CHECK_CMD:
X	case 0X00:
N		uart_download_status=1;
N		payload[0]=0x00;
N		cmd_response(LINK_CHECK_CMD+1,5,payload);
X		cmd_response(0X00+1,5,payload);
N		erase_fenable=1;
N		break;
N
N	case CRC_CHECK_CMD:
X	case 0X10:
N		crc_start_addr = ( buff[1]|(buff[2]<<8)|(buff[3]<<16)|(buff[4]<<24) );
N		crc_end_addr = ( buff[5]|(buff[6]<<8)|(buff[7]<<16)|(buff[8]<<24) );
N
N		//bim_fflash_wp_ALL();
N
N		make_crc32_table();
N
N
N		read_flash_addr=crc_start_addr;
N
N		for(uint16_t i = 0; i < (crc_end_addr-crc_start_addr+1)/256; i++)
N		{
N			bim_flash_read(FLASH_SPACE_TYPE_MAIN, read_flash_addr/4, 256, read_data);
N
N			calcuCrc = make_crc32(calcuCrc,read_data,256);
N
N			read_flash_addr+= 256;
N		}
N		payload[0]= calcuCrc;
N		payload[1]= calcuCrc>>8;
N		payload[2]= calcuCrc>>16;
N		payload[3]= calcuCrc>>24;
N		cmd_response(CRC_CHECK_CMD,8,payload);
X		cmd_response(0X10,8,payload);
N
N		break;
N	case STAY_ROM_CMD:
X	case 0XAA:
N		uart_download_status=1;
N		payload[0]=buff[1];
N		cmd_response(STAY_ROM_CMD,5,payload);
X		cmd_response(0XAA,5,payload);
N
N		break;
N	case SET_BAUDRATE_CMD:
X	case 0X0F:
N
N		baudrate_set =  buff[1]|(buff[2]<<8)|(buff[3]<<16)|(buff[4]<<24) ;
N
N		uart_clk_div    = 16000000/baudrate_set;
N
N		REG_APB3_UART_CFG  = ((uart_clk_div-1)<<8) +
X		(*((volatile unsigned long *) 0x00806300))  = ((uart_clk_div-1)<<8) +
N		                     (stop_bits   <<7) +
X		                     (0x0   <<7) +
N		                     (data_len    <<3) +
X		                     (0x3    <<3) +
N		                     (irda_mode   <<2) +
X		                     (0x0   <<2) +
N		                     (uart_rx_en  <<1) +
X		                     (0x1  <<1) +
N		                     uart_tx_en;
X		                     0x1;
N
N
N
N		bim_delay_ms(buff[5]*2);
N
N		payload[0]=buff[1];
N		payload[1]=buff[2];
N		payload[2]=buff[3];
N		payload[3]=buff[4];
N		payload[4]=buff[5];
N		cmd_response(SET_BAUDRATE_CMD,9,payload);
X		cmd_response(0X0F,9,payload);
N		bim_icu_init(ICU_CLK_64M);
N		break;
N	case SET_RESET_CMD:
X	case 0X0E:
N		if(buff[1]==0xa5)
N		{
N			bim_wdt_enable(0X10);
N			while(1);
N		}
N
N		break;
N	}
N}
N
Nvoid cmd_response( uint8_t cmd, uint8_t length, uint8_t *payload )
N{
N	uint8_t response_buff[16],i;
N
N	if(length<4)
N		return;
N
N	response_buff[0]=0x04;
N	response_buff[1]=0x0e;
N	response_buff[2]=length;
N	response_buff[3]=0x01;
N	response_buff[4]=0xe0;
N	response_buff[5]=0xfc;
N	response_buff[6]=cmd;
N
N	for(i=0; i<length-4; i++)
N		response_buff[7+i]=payload[i];
N
N	uart_send(response_buff,length+3);
N
N}
N
Nvoid operate_flash_cmd_response( uint8_t cmd, uint8_t status,uint16_t length, uint8_t *payload )
N{
N	uint8_t response_buff[4200];
N	uint16_t    i;
N
N	if(length<2)
N		return;
N
N	response_buff[0]=0x04;
N	response_buff[1]=0x0e;
N	response_buff[2]=0xff;
N	response_buff[3]=0x01;
N	response_buff[4]=0xe0;
N	response_buff[5]=0xfc;
N	response_buff[6]=0xf4;
N
N	response_buff[7]=(length&0xff);
N	response_buff[8]=length>>8;
N	response_buff[9]=cmd;
N	response_buff[10]=status;
N
N
N	for(i=0; i<(length-2); i++)
N		response_buff[11+i]=payload[i];
N
N	uart_send(response_buff,length+9);
N
N}
N
N
N
N
N#endif
N
N
N
